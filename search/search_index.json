{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Ceci est un regroupement des diff\u00e9rents supports de cours \u00e9crits. Certains commen\u00e7ant \u00e0 dater ont \u00e9t\u00e9 remis au gout du jour.","title":"Introduction"},{"location":"#introduction","text":"Ceci est un regroupement des diff\u00e9rents supports de cours \u00e9crits. Certains commen\u00e7ant \u00e0 dater ont \u00e9t\u00e9 remis au gout du jour.","title":"Introduction"},{"location":"intro/","text":"Introduction Ceci est un regroupement des diff\u00e9rents supports de cours \u00e9crits. Certains commen\u00e7ant \u00e0 dater ont \u00e9t\u00e9 remis au gout du jour.","title":"Introduction"},{"location":"intro/#introduction","text":"Ceci est un regroupement des diff\u00e9rents supports de cours \u00e9crits. Certains commen\u00e7ant \u00e0 dater ont \u00e9t\u00e9 remis au gout du jour.","title":"Introduction"},{"location":"langC/","text":"Langage C niveau 1 SUIVI DES VERSIONS DU DOCUMENT Creation : 1990/10/20 Last change : 2019/10/05 passage en markdown, et aux compilateurs actuelxs. Langage C niveau 1 Pr\u00e9sentation g\u00e9n\u00e9rale Introduction, historique. Un premier programme. Les types et les variables Les variables. Les types de bases. Les bool\u00e9ens. Construction de types. Les tableaux: Les structures: Les classes des variables. auto static extern volatile const register Les constantes. Les op\u00e9rateurs. Les op\u00e9rateurs logiques: Les op\u00e9rateurs arithm\u00e9tiques: Les op\u00e9rateurs sur les bits: Les op\u00e9rateurs sur les pointeurs Autres op\u00e9rateurs: Les Pointeurs Affectation des pointeurs. Les pointeurs et les cha\u00eenes de caract\u00e8res. Proc\u00e9dures et fonctions. Pointeur de fonction. R\u00e9cup\u00e9ration des param\u00e8tres d'une commande. Allocation dynamique. Le Pr\u00e9processeur C : cpp #define directive # directive ## Compilation conditionnelle. Directives de compilation. Les fonctions standards d'entr\u00e9es sorties. les entr\u00e9es sorties par d\u00e9faut Pr\u00e9sentation g\u00e9n\u00e9rale Introduction, historique. Le langage C a \u00e9t\u00e9 d\u00e9velopp\u00e9 par DANIEL RITCHIE au m\u00eame moment que le syst\u00e8me d'exploitation UNIX. Unix a \u00e9t\u00e9 \u00e9crit quasi enti\u00e8rement en langage C (Sur 13000 lignes de codes, seulement 800 sont \u00e9crites en assembleur). Ce n'\u00e9tait pas la premi\u00e8re fois qu'un syst\u00e8me d'exploitation \u00e9tait \u00e9crit dans un langage \u00e9volu\u00e9, mais UNIX est le premier \u00e0 conna\u00eetre une large diffusion. Le langage C est un langage structur\u00e9 de haut niveau ne faisant que peu (ou pas du tout) de contr\u00f4les de type. Exemple : la variable 'c' \u00e9tant d\u00e9fini comme caract\u00e8re 'c = 65;' est correct pour le compilateur C alors que l'\u00e9quivalent en Pascal (Langage de haut niveau tr\u00e8s strict sur les contr\u00f4les de type) ferait hurler le compilateur. Les faiblesses du langage C viennent de l'objectif m\u00eame de ses concepteurs : \u00e9crire le syst\u00e8me UNIX. Il ne comporte aucune instruction d'entr\u00e9es sorties de gestion de la m\u00e9moire etc ... Tous ces m\u00e9canismes sont fournis dans une biblioth\u00e8que de fonctions dans l'environnement syst\u00e8me, heureusement le noyau des fonctions (environ 300 fonctions) est le m\u00eame quelque soit le syst\u00e8me sur lequel on travaille que se soit UNIX ou non. A l'heure actuelle le langage C est normalis\u00e9 par l'ANSI (depuis d\u00e9cembre 1989). Le pr\u00e9sent document pr\u00e9sente les principales difficult\u00e9s du langage C, il ne constitue pas un cours, pour de plus plus amples d\u00e9tails on se reportera au livre \\\"Le langage C de Kerningham et Ritchie.\\\" et si possible \u00e0 la derni\u00e8re version . Un premier programme. /* $cat mini.c */ void main ( void ){ } $cc mini.c $a .out $ Rajoutons une ligne gr\u00e2ce \u00e0 l'\u00e9diteur vi. /* $cat mini.c */ ##include sdtio.h void main ( void ) { printf ( Bonjour. \\n ); /* Ceci est un commentaire */ } $cc mini.c $a .out Bonjour. $ Un programme C est form\u00e9 d'une ou plusieurs fonctions. Une seule est obligatoire, celle qui a pour nom 'main'. En fait c'est le point d'entr\u00e9e du programme : c'est la premi\u00e8re fonction que le programme ex\u00e9cute. La fonction 'main' peut se trouver n'importe o\u00f9 dans le programme (en g\u00e9n\u00e9ral au d\u00e9but ou \u00e0 la fin du programme pour des questions de lisibilit\u00e9.). La fonction 'main' ex\u00e9cutera en g\u00e9n\u00e9ral d'autres fonctions soit celles qui proviendront du programme lui-m\u00eame, soit celles qui proviennent de biblioth\u00e8ques, 'printf' est l'une de ces fonctions sa d\u00e9claration se trouve dans le fichier stdio.h qui se trouvent dans le r\u00e9pertoire /usr/include (sous UNIX). Les parenth\u00e8ses qui suivent le nom de la fonction encadrent les param\u00e8tres qui lui sont pass\u00e9s. Les accolades encadrent les instructions \u00e0 ex\u00e9cuter (\u00e9quivalent au Begin End du Pascal). Les commentaires sont encadr\u00e9s par les suites de caract\u00e8res '/*' et '*/'. Un exemple plus cons\u00e9quent : /* min.c */ ##include stdio.h /* * La fonction min renvoie le plus petit des deux entiers qui * lui sont pass\u00e9 en param\u00e8tres. */ int min ( int a , int b ) { return ( a b ? a : b ); } void main . c (){ printf ( le minimum de 4 et 10 est : %d \\n , min ( 10 , 4 )); } $cc -o min min.c $min le minimum de 4 et 10 est : 4 $ Les types et les variables Les variables. Les variables peuvent \u00eatre d\u00e9finies \u00e0 l'ext\u00e9rieur ou \u00e0 l'int\u00e9rieur des fonctions. A l'int\u00e9rieur des fonctions les variables n'existent qu'\u00e0 partir de l'endroit o\u00f9 elles sont d\u00e9clar\u00e9es. /* $cat var.c */ ##include stdio.h int globale_au_fichier ; void ma_procedure () { int locale_a_la_fonction ; locale_a_la_fonction = 2 ; globale_au_fichier = 4 ; printf ( procedure: locale_a_la_fonction = %d \\n , locale_a_la_fonction ); printf ( procedure: globale_au_fichier = %d \\n , globale_au_fichier ); } void main ( void ) { int locale_a_la_fonction = 1 ; globale_au_fichier = 1 ; ma_procedure (); printf ( main: locale_a_la_fonction = %d \\n , locale_a_la_fonction ); printf ( main: globale_au_fichier = %d \\n , globale_au_fichier ); } Attention le langage C fait la diff\u00e9rence entre majuscules et minuscules, ici les appels \u00e0 bon() et \u00e0 BON() ne sont pas identiques, mais correspondent \u00e0 deux fonctions diff\u00e9rentes. Faire d'autant plus attention que sur certaines implantations du langage C le compilateur fait la diff\u00e9rence mais pas l'\u00e9diteur de liens. Les types de bases. char : caract\u00e8res short : entiers courts int : entiers long : entiers longs float : r\u00e9els double : r\u00e9els double pr\u00e9cision. La taille de ces types (nombre d'octet pris en m\u00e9moire) varie suivant les versions. La seule chose qui vous est assur\u00e9 est que: char = short = int = long = float = double Tous ces types peuvent recevoir le mot cl\u00e9 unsigned pour non sign\u00e9. Exemple : int i ; unsigned char c ; long j ; Les bool\u00e9ens. Il n'y a pas de variables bool\u00e9ennes (au contraire du Pascal) les expressions sont \u00e9valu\u00e9es num\u00e9riquement, un 0 correspond \u00e0 FAUX, tout autre valeur correspond \u00e0 VRAI. Construction de types. [ ] d\u00e9finit les vecteurs et tableaux struct les structures (\u00e9quivalent au record du pascal) union \u00e9quivalent au Record case du Pascal typedef Permet de d\u00e9finir des types * pour les pointeurs. Les tableaux: int tab [ 32 ]; /* d\u00e9fini un tableau de 32 entiers */ int * ptr [ 32 ]; /* d\u00e9fini un tableau de 32 pointeurs sur des entiers.*/ /* * tableaux \u00e0 plusieurs dimensions sont d\u00e9finis comme les vecteurs. */ int matrice [ 20 ][ 30 ]; /* d\u00e9fini un tableau de 20 lignes de 30 entiers.*/ Note Il n'est pas possible de borner un tableau le premier \u00e9l\u00e9ment est toujours le num\u00e9ro ZERO. La taille d'un tableau est une constante, elle ne peut \u00eatre d\u00e9finie dynamiquement. le seul cas o\u00f9 la taille peut ne pas \u00eatre d\u00e9finie est dans la d\u00e9claration de variables d'une fonction. DAns le cas d'un tableau multi-dimensionnel seul le premier niveau peut ne pas \u00eatre d\u00e9fini. Exemple : /* parcours_tab.c */ #include stdio.h #define MAXSIZE 32 int tableau [ MAXSIZE ]; int i ; void main ( int argc , char * argv []) { for ( i = 0 ; i = MAXSIZE - 1 ; i ++ ) { tableau [ i ] = i ; /* * parcours de TOUS les \u00e9l\u00e9ments du tableau */ } for ( i = 0 ; i argc ; i ++ ){ printf ( argument %d: %s \\n , i , argv [ i ]); } } On pourrait tout aussi bien \u00e9crire le programme de la mani\u00e8re suivante : /* parcours_tab.c */ #include stdio.h #define MAXSIZE 32 int tableau [ MAXSIZE ]; int i ; void main ( int argc , char ** argv ) { for ( i = 0 ; i = MAXSIZE - 1 ; i ++ ) { tableau [ i ] = i ; /* * parcours de TOUS les \u00e9l\u00e9ments du tableau */ } for ( i = 0 ; i argc ; i ++ ){ printf ( argument %d: %s \\n , i , argv [ i ]); } } Les structures: Il existe deux mani\u00e8res de d\u00e9finir des structures. struct { int x , y ; /* Coordonn\u00e9es d un pixel \\*/ int couleur ; /* couleur du pixel \\*/ } pix , * p ; Ici on d\u00e9finit 'pix' comme \u00e9tant un structure et 'p' comme \u00e9tant un pointeur sur une structure. La structure d\u00e9finie n'a pas de nom. Les \u00e9l\u00e9ments sont accessibles par : pix.x pix.y pix.couleur struct point { int x , y ; int couleur ; } pix ; struct point * p ; La structure a un nom 'point' qui peut \u00eatre r\u00e9utiliser dans un programme. Un autre moyen est d'utiliser le constructeur de type 'typedef' typedef struct _point { int x , y ; int couleur ; } Point ; /* le type point est d\u00e9fini, CE N EST PAS UNE VARIABLE */ Point pix ; struct _point * p ; le '_point' au niveau de typedef struct _point { n'est pas obligatoire il peut \u00eatre omis dans ce cas. Les deux moyens sont bons, et utile dans certains cas pour faire des structures r\u00e9cursives. /* D\u00e9finition d une structure de type noeud */ typedef struct { noeud * fils_gauche ; /* Interdit de faire cela */ noeud * fils_droit ; int valeur ; } noeud ; /* * D\u00e9finition de 2 types de structures * noeud : objet de type noeud * noeudptr : object de type pointeur vers un objet de type noeud */ typedef struct _noeud { struct _noeud * fils_gauche ; /* On d\u00e9finit le nom _noeud */ struct _noeud * fils_droit ; /* qui ne sera utilis\u00e9 qu ici */ int valeur ; } noeud , * noeudptr ; La mani\u00e8re la plus lisible est d'utiliser la d\u00e9claration avec typedef , de plus elle \u00e9vite de r\u00e9\u00e9crire \u00e0 chaque fois le mot struct . Les classes des variables. Dans un soucis de simplification, tout les modificateurs ont \u00e9t\u00e9 regroup\u00e9s. Les variables sont caract\u00e9ris\u00e9es par leur types et par leurs classe de stockage, c'est \u00e0 dire leur visibilit\u00e9 : locale ou globale. Les variables ont une classe par d\u00e9faut qui d\u00e9pend de l'endroit o\u00f9 elles sont d\u00e9finies. Les classes sont : auto , static , extern , const , volatile et register . auto auto n'est autoris\u00e9 que pour des variables locales \u00e0 int\u00e9rieure d'un bloc d'instruction, c'est la d\u00e9claration utilis\u00e9e par d\u00e9faut. En fait ne sert \u00e0 rien, \u00e0 part forcer l'optimiseur de code \u00e0 ne pas utiliser register . static dans une fonction Hors d'une fonction Sans static Dynamique, locale \u00e0 la fonction globale \u00e0 tous les fichiers Avec static Statique, permanente, visible dans la fonction Statique, permanente, visible dans le fichier. extern Permet de faire r\u00e9f\u00e9rence \u00e0 une variable d\u00e9j\u00e0 d\u00e9clar\u00e9e, IL N'Y A PAS RESERVATION DE PLACE MEMOIRE, il est indispensable que la variable soit r\u00e9ellement d\u00e9clar\u00e9e dans un autre fichier ou module du programme, sinon il y aura une erreur lors de l'\u00e9dition de liens. En g\u00e9n\u00e9ral, on peut se dispenser du mot cl\u00e9 extern mais certains compilateurs veulent que les variables ne soient d\u00e9clar\u00e9es qu'une seule fois dans tout le programme. volatile Permet de dire au compilateur de ne pas faire d'optimisation sur la variable. la variable peut \u00eatre mise \u00e0 jour \u00e0 tout moment par une autre tache (thread). const const permet d'\u00e9viter la modification des variables. Elles peuvent juste \u00eatre initialis\u00e9es \u00e0 la d\u00e9claration. Permet de g\u00e9n\u00e9rer des erreurs de compilation si il y a une terntative de modfication de la variable. Example #include stdio.h size_t longueur_de_chaine ( const char chaine [] ) { register size_t longueur ; for ( longueur = 0 ; chaine [ longueur ]; longueur ++ ); return longueur ; } void main ( int argc , char ** argv ) { int i ; for ( i = 0 ; i argc ; i ++ ){ printf ( argument %2d - longueur=%3ld - %s \\n , i , longueur_de_chaine ( * ( argv + i )), argv [ i ]); } } register Demande que la variable soit rang\u00e9e dans un registre dans la mesure du possible, c'est \u00e0 dire qu'il y ait un registre de libre et que la taille de la variable soit inf\u00e9rieure ou \u00e9gale \u00e0 celle du registre de la machine. Ceci est surtout utilis\u00e9 pour les variables de boucles et acc\u00e9l\u00e8re de mani\u00e8re sensible l'ex\u00e9cution de programme. Exemple : /* sans.c */ void main ( void ) { int i , j , s ; for ( i = 1 ; i = 1000 ; i ++ ) { s = 0 ; for ( j = 0 ; j 10000 ; j += i ) s += j ; } } /* $cat avec.c */ void main ( void ) { register int i , j , s ; for ( i = 1 ; i = 1000 ; i ++ ) { s = 0 ; for ( j = 0 ; j 10000 ; j += i ) s += j ; } } $cc -o sans sans.c $cc -o avec avec.c $time sans 0 .8 real 0 .7 user 0 .0 sys $time avec 0 .7 real 0 .3 user 0 .0 sys $ Avec les machines actuelles il faudra peut \u00eatre rajouter deux 0 dans les boucles pour voir quelque chose. Les constantes. Les constantes peuvent \u00eatre de type : entier : 12 , 012 , 0xff , 0L r\u00e9el : 35.2 , .78e-23 caract\u00e8re : 'c' , '\\n' , '\\007' cha\u00eene : \\\"\\0x07Chaine qui \\\\\"sonne\\\\\" et va \u00e0 la ligne \\n\\\" Les constantes enti\u00e8res peuvent \u00eatre en base 10,base 8 (Premier chiffre est un 0 ) ou en base 16 (commen\u00e7ant par 0x). le suffixe L indique une constante de type long. Le caract\u00e8re ' joue le r\u00f4le de caract\u00e8re d'\u00e9chappement, il permet de repr\u00e9senter certains caract\u00e8res: \\n fin de ligne \\t tabulation \\b backspace \\r retour chariot \\f form feed (saut de page) \\\\ \\ \\\" \" \\' ' \\0 le caract\u00e8re de code ASCII z\u00e9ro NULL Le caract\u00e8re \\ permet d' \u00e9chapper un caract\u00e8re dans les d\u00e9finitions de constantes caract\u00e8re ainsi que dans les constantes cha\u00eene. Exemple cha\u00eene form\u00e9e de deux guillemets : \"\\\"\\\"\" . Les op\u00e9rateurs. Les op\u00e9rateurs logiques: \\ inf\u00e9rieur sup\u00e9rieur => Sup\u00e9rieur ou \u00e9gal = inf\u00e9rieur ou \u00e9gal == \u00e9gal != diff\u00e9rent ! non logique et logique || ou logique Les op\u00e9rateurs arithm\u00e9tiques: + plus - moins * multiplication / division % modulo ++ auto-incr\u00e9mentation (pr\u00e9fixe '++var'ou postfixe 'var++') -- auto-d\u00e9cr\u00e9mentation (idem) Les op\u00e9rateurs sur les bits: ~ compl\u00e9ment et | ou ^ ou exclusif d\u00e9calage de bits vers la droite d\u00e9calage de bits vers la gauche Remarque pour les op\u00e9rateurs arithm\u00e9tique et sur les bits on notera le raccourci suivant : a (op)=b \u00e9quivaut \u00e0 a = a (op) b Ceci est un raccourci d'\u00e9criture mais correspond aussi \u00e0 une optimisation du code du programme. Les op\u00e9rateurs sur les pointeurs * indirection adresse d'une variable - acc\u00e8s aux champs d'une structure ( p->x est \u00e9quivalent \u00e0 (*p).c ) Certains op\u00e9rateurs acceptent des pointeurs : + , - , ++ , -- op\u00e9rateurs arithm\u00e9tiques * , -> indirections (TYPE) conversion de type , , = , = , == , != op\u00e9rateurs de comparaison Exemple si p est un pointeur sur un objet et i un entier p + i est l'adresse du i-\u00e8me objet suivant l'objet point\u00e9 par p Autres op\u00e9rateurs: (TYPE) Op\u00e9rateur unaire permettant de convertir une variable dans le type TYPE . sizeof(OBJET) Taille de l'objet en octets (OBJET peut \u00eatre une variable ou le type d'une variable) = Affectation simple. e ? e1 : e2 Expression conditionnelle sa valeur est e1 si e est vrai e2 sinon. e1,e2,...,eq Liste d'expressions \u00e9valu\u00e9es s\u00e9quentiellement de e1 puis e2 jusqu'\u00e0 eq, la valeur de la liste vaut eq Exemple : (i=2,j=i++,5*j-i) a pour valeur 7, de plus i vaut 3 et j vaut 2 Les Pointeurs Une variable de type pointeur est une variable contenant une adresse. On peut d\u00e9finir des pointeurs sur des variables de type de base ou sur des variables construites \u00e0 partir des types de bases. Le type pointeur d'un objet de type 'TYPE' est : 'TYPE *' . Exemple : int * p ; /* Pointeur sur un entier */ struct _point * pixptr ; /* Pointeur sur un objet dont le type est struct _point */ L'objet point\u00e9 par le pointeur 'p' est not\u00e9 : '*p' , l'adresse d'un objet 'q' est not\u00e9e ' q '; Exemple : (sur les versions actuelles peut donner un warning \u00e0 la compilation, ne pas en tenir compte) /* $cat demoptr.c */ #include stdio.h void main ( void ){ int i ; int * p ; char * ch ; i = 10 ; p = i ; /* p contient l adresse de la variable i */ ch = Ceci est une cha\u00eene. \\n ; /* * ch contient l adresse de la cha\u00eene qui sera rang\u00e9e dans le * segment des donn\u00e9es au moment de la g\u00e9n\u00e9ration de code. Le * d\u00e9limiteur de cha\u00eene EST rajout\u00e9 au moment de la g\u00e9n\u00e9ration de * code. */ printf ( Valeur du contenu \u00e0 l adresse de p est %d \\n , * p ); printf ( %s , ch ); printf ( ch ); /* donne la m\u00eame chose que la ligne pr\u00e9c\u00e9dente */ } $ cc -o demoptr.e demoptr.c $ $ ./demoptr.e Valeur du contenu \u00e0 l adresse de p est 10 Ceci est une cha\u00eene. Ceci est une cha\u00eene. $ Les op\u00e9rations sur les pointeurs sont : L'affectation simple : = Les op\u00e9rations arithm\u00e9tiques : + , - , ++ , -- L'indirection : * , -> Les conversions de type et le calcul de la taille. Les op\u00e9rateurs de comparaison. Affectation des pointeurs. La d\u00e9claration d'un pointeur r\u00e9serve de la place pour le pointeur ET NON pour l'objet point\u00e9. Exemple : /* $cat faux.c */ void main ( void ) { int * p ; /* R\u00e9servation de place pour le pointeur uniquement */ * p = 120 ; /* Pas de r\u00e9servation de place pour l entier */ } $ cc -o faux faux.c $ ./faux Bus error ( core dumped ) $ Attention la diff\u00e9rence de type entre les deux membres lors d'une affectation n'est pas trait\u00e9e comme une erreur fatale mais donne lieu \u00e0 un 'warning'. Exemple : /* $cat demoptr2.c */ #include stdio.h void main ( void ) { long i ; long * p ; char * c ; i = p ; /*Donne lieu \u00e0 un warning mais pas une erreur fatale */ i = ( long ) p ; /* * Bonne m\u00e9thode ne donne lieu \u00e0 aucun commentaire de la part * du compilateur et l on sait ce que l on fait !!!! */ i = 0x41424344 ; p = i ; c = ( char * ) p ; /* La valeur du pointeur p est convertie en pointeur sur * caract\u00e8re */ printf ( %c \\n , * c ); /* Affiche le contenu du premier octet de la variable i ou le dernier*/ } La r\u00e8gle \u00e0 appliquer est de toujours \u00e9crire des expressions homog\u00e8nes pour \u00e9viter les warnings, de plus l'on sait ce que l'on fait !!!! (En principe) Les pointeurs et les cha\u00eenes de caract\u00e8res. Une cha\u00eene de caract\u00e8res en C est est une suite d'octets se terminant par le caract\u00e8re de code ASCII z\u00e9ro (NULL). Ainsi \\\"chaine\\\" est une constante ayant pour valeur l'adresse d'un zone m\u00e9moire dont les 7 premiers octets ont pour valeur 'c' 'h' 'a' 'i' 'n' 'e' ET '\\0'. Exemple : /* $cat demoptr3.c */ #include stdio.h char * p , c ; int i ; void main ( void ) { p = ABCDEFGHIJKLMNO ; c = * ( p + 2 ); /* c contient le caract\u00e8re C . */ i = * ((( int * ) p ) + 1 ); printf ( sizeof(int*) = %ld \\n , sizeof ( int * )); printf ( sizeof(int) = %ld \\n , sizeof ( int )); printf ( i = %x \\n , i ); } Regardons la derni\u00e8re expression de plus pr\u00e9s : (int *) p : p est un pointeur sur des caract\u00e8res il est converti en pointeur sur un entier. ((int *) p) + 1 : On obtient l'adresse de l'entier suivant, le d\u00e9placement d\u00e9pend de l'impl\u00e9mentation sur la machine du langage, en pratique on se d\u00e9place de 2, 4 ou 8 octets *(((int *) p) + 1) : On obtient la valeur de l'entier suivant (0x45464748 ou 0x48474645 suivant la taille des indiens). On peut construire une cha\u00eene de caract\u00e8res de diff\u00e9rentes mani\u00e8res: En utilisant les guillemets, la caract\u00e8re de fin de cha\u00eene (NULL) est automatiquement rajout\u00e9. En remplissant \u00e0 la main les zones d'un tableau. En utilisant des fonctions de la biblioth\u00e8que standard du C tel que strcpy() , strcat() ... Exemple: /* $cat chaine.c */ #include stdio.h #include string.h void main ( void ) { char ch [ 10 ], chh [ 10 ]; char * chaine ; chaine = ijklmn ; /* 1\u00e8re m\u00e9thode */ ch [ 0 ] = a ; /* 2\u00e8me m\u00e9thode */ ch [ 1 ] = b ; ch [ 2 ] = \\0 ; ( void ) strcpy ( chh , cdefgh ); /* 3\u00e8me m\u00e9thode */ ( void ) strcat ( ch , chh ); printf ( chaine contient : %s \\n , chaine ); printf ( chh contient : %s \\n , chh ); printf ( ch contient : %s \\n , ch ); ch [ 4 ] = \\0 ; printf ( La chaine S ARRETE au premier caract\u00e8re \\\\ 0 \\n ); printf ( ch vaut maintenant : %s \\n , ch ); } A l'ex\u00e9cution : $ cc chaine.c $ ./a.out chaine contient : ijklmn chh contient : cdefgh ch contient : abcdefgh La chaine S ARRETE au premier caract\u00e8re \\0 ch vaut maintenant : abcd $ Proc\u00e9dures et fonctions. En C il n'y a pas de diff\u00e9rence entre une proc\u00e9dure et une fonction, par d\u00e9faut une fonction retourne un entier. Une proc\u00e9dure \u00e9tant une fonction qui ne retourne pas de valeur. Une fonction peut \u00e9galement retourner l'un des types de base ou un pointeur. Attention Dans une fonction les variables sont par d\u00e9faut de classe 'auto', c'est \u00e0 dire dynamique. En fait elles sont allou\u00e9es dans la pile et disparaissent apr\u00e8s l'ex\u00e9cution de la fonction. En C les param\u00e8tres d'une fonction sont tous pass\u00e9s par valeurs. Si l'on veut passer des param\u00e8tres par r\u00e9f\u00e9rence il est n\u00e9cessaire de passer l'adresse de la variable. Exemple : /* $cat para.c*/ #include stdio.h /* La fonction swap1 ne marche pas */ void swap1 ( int a , int b ) { int temp ; temp = a ; a = b ; b = temp ; } /* La fonction swap marche. */ void swap ( int * a , int * b ) { int temp ; temp = * a ; * a = * b ; * b = temp ; } void main ( void ) { int a , b ; a = 10 ; b = 5 ; printf ( Les valeurs de a et b sont a=%d , b=%d \\n , a , b ); swap1 ( a , b ); printf ( la fonction swap1 ne marche pas a=%d , b = %d \\n , a , b ); swap ( a , b ); printf ( la focntion swap marche a=%d , b = %d \\n , a , b ); } Pointeur de fonction. On peut d\u00e9finir des fonctions sur n'importe quel type de variables; on peut aussi d\u00e9clarer des pointeurs sur des fonctions. Exemple: /* $cat foncptr.c */ ##include stdio.h typedef int ( * adfonc ) ( int i ); /* declare adfonc comme pointeur de fonction retournant un entier. */ int f0 ( int i ) { printf ( La valeur du param\u00e8tre de f0 est %d \\n , i ); } int f1 ( int i ) { printf ( La valeur du param\u00e8tre de f1 est %d \\n , i ); } int f2 ( int i ) { printf ( La valeur du param\u00e8tre de f2 est %d \\n , i ); } void main ( void ) { int i ; adfonc tab [ 3 ] = { f0 , f1 , f2 }; for ( i = 0 ; i 3 ; i ++ ){ ( * tab [ i ])( i ); } } $ cc -o foncptr foncptr.c $ ./foncptr La valeur du param\u00e8tre de f0 est 0 La valeur du param\u00e8tre de f1 est 1 La valeur du param\u00e8tre de f2 est 2 $ Note On \u00e9crit tab[0] = f0; et non tab[0] = car f0 est une constante dont la valeur est l'adresse de la fonction f0() tout comme pour un tableau o\u00f9 t et t[0] sont \u00e9quivalents. R\u00e9cup\u00e9ration des param\u00e8tres d'une commande. La plupart des commandes UNIX demandent des param\u00e8tres pour s'ex\u00e9cuter. De m\u00eame, il est possible de r\u00e9cup\u00e9rer des param\u00e8tres pass\u00e9s sur la ligne de commande pour nos propres programmes C. Exemple: /* cat litarg.c */ #include stdio.h void main ( int argc , char ** argv ) { int i ; for ( i = 0 ; i argc ; i ++ ) printf ( Argument n\u00b0 %d est %s \\n , i , argv [ i ]); } $cc -o arg litarg.c $ ./arg bonjour cc -o argument Argument n\u00b0 0 est arg Argument n\u00b0 1 est bonjour Argument n\u00b0 2 est cc Argument n\u00b0 3 est -o Argument n\u00b0 4 est argument $ $ ./arg Argument n\u00b0 0 est arg $ On remarque qu'un programme poss\u00e8de au moins un argument : le nom du programme. Note Si vous travaillez sous UNIX Essayer 'arg *' cela vous donnera la liste des fichiers sous votre directory courante. $ ./arg *.c Argument n\u00b0 0 est arg Argument n\u00b0 1 est lit_arg.c Argument n\u00b0 2 est foncptr.c Argument n\u00b0 3 est para.c $ Sous UNIX (ou DOS) il est possible de lire la table d'environnement pass\u00e9e au programme; la d\u00e9claration est la suivante : /* $cat env.c */ ##include stdio.h void main ( int argc , char ** argv , char ** envp ) { int i ; for ( i = 0 ; envp [ i ]; i ++ ) printf ( %s \\n , envp [ i ]); /* La condition est fausse quand envp[i] vaut NULL (c.\u00e0.d 0) */ } $env PATH = :/usr/bin:/bin HOME = /usr/alfred TZ = GMT0 TERM = VT100 $ Permet de lire la table d'environnement. Allocation dynamique. L'allocation dynamique nous permet de r\u00e9server de l'espace m\u00e9moire durant l'ex\u00e9cution du programme. Exemple sur des listes chain\u00e9es : /* cat liste.c */ ##include stdio.h /* Fonctions standards d entr\u00e9es sorties */ ##include stdlib.h /* pour malloc */ ##include string.h /* Fonctions de manipulations de chaines */ ##define MAXSIZE 32 typedef struct _LISTE { char nom [ MAXSIZE ]; struct _LISTE * suivant ; } LISTE , * LISTEPTR ; LISTEPTR deblist = NULL ; /* pointeur initialis\u00e9 \u00e0 vide */ LISTEPTR finlist = NULL ; /* * Fonction d ajout d un \u00e9l\u00e9ment */ LISTEPTR ajoute ( char * s ) { LISTEPTR p ; /* Allocation d une nouvelle structure */ p = ( LISTEPTR ) malloc ( sizeof ( LISTE )); /* mise \u00e0 0 de la partie memoire obtenue */ ( void ) memset ( p , sizeof ( LISTE ), 0 ); /* si p vaut NULL il n y a plus de place */ if ( p == NULL ) { fprintf ( stderr , D\u00e9passement capacit\u00e9 m\u00e9moire !! \\n ); exit ( 1 ); } if ( deblist == NULL ){ deblist = finlist = p ; } else { finlist - suivant = p ; finlist = p ; finlist - suivant = NULL ; } /* on recopie en gardant un ocet pour le caratere de fon de chaine */ strncpy ( finlist - nom , s , MAXSIZE - 1 ); return finlist ; } /* * Supprimme un \u00e9l\u00e9ment de la liste */ void supprime ( LISTEPTR pl ) { LISTEPTR p , q ; if ( pl == NULL ) return ; /* Si chaine vide on ne fait rien */ p = q = deblist ; /* Initialisation de p et q */ if ( pl == deblist ){ deblist = deblist - suivant ; if ( pl == finlist ) finlist = NULL ; } else { do { /* Parcours de la liste */ q = p ; /* jusqu \u00e0 pl */ p = p - suivant ; } while (( q - suivant != pl ) || ( p == NULL )); if ( p == NULL ) return ; /* Si pl n est pas dans la liste */ q - suivant = p - suivant ; if ( q - suivant == NULL ) /* si c est le dernier element */ finlist = q ; } free ( pl ); } void main ( void ) { LISTEPTR p ; LISTEPTR curptr = NULL ; ( void ) ajoute ( alfred ); curptr = ajoute ( michel ); ( void ) ajoute ( robert ); ( void ) ajoute ( un tres long nom de prenom qui depasse les 32 caract\u00e8res ); /* On affiche la liste */ for ( p = deblist ; p ; p = p - suivant ) printf ( %s \\n , p - nom ); supprime ( curptr ); /* On supprime michel*/ printf ( michel est supprim\u00e9 \\n ); for ( p = deblist ; p ; p = p - suivant ) printf ( %s \\n , p - nom ); } $ $./liste alfred michel robert michel est supprim\u00e9 alfred robert $ La fonction d'allocation de m\u00e9moire est 'malloc' elle alloue le nombre d'octets pass\u00e9 en param\u00e8tre. Attention toujours passer par la fonction sizeof() pour determiner la taille d'une structure, ceci pour des probl\u00e8mes de portabilit\u00e9. Exemple : /* mauvais.c */ void main ( void ) { int * p ; p = ( int * ) malloc ( 2 ); * p = 12 * 256 * 256 ; } /* bon.c */ void main ( void ) { int * p ; p = ( int * ) malloc ( sizeof ( int )); * p = 12 * 256 * 256 ; } Le programme 'mauvais.c' marche sur DOS o\u00f9 la taille des entiers est de 2 octets; mais pas sur d'autres machines o\u00f9 la taille des entiers est de 4 octets (syst\u00e8me d'exploitation 32 bits). Le Pr\u00e9processeur C : cpp Le pr\u00e9processeur permet de faire de la compilation conditionnelle, de d\u00e9finir des macros (comme en assembleur), et de donner des directives de compilation. Toutes ces instructions commencent par le caract\u00e8re #. Certains compilateurs tiennent absolument \u00e0 ce que ce soit le premier caract\u00e8re d'une ligne. Attention Toutes les directives (commen\u00e7ant par #) ne se terminent pas par un point-virgule. #define Permet de d\u00e9finir des entit\u00e9s des macros instructions. Une ligne trop longue peut \u00eatre coup\u00e9e par le caract\u00e8re d'\u00e9chappement \\ . Exemple : #define _UNIX l'entit\u00e9 _UNIX est d\u00e9finie. #define MAX 43 Dans tout le programme suivant la d\u00e9finition MAX sera remplac\u00e9 par 43 #include stdio.h #include string.h #define COMMENTAIRE() { \\ printf( Un #define trop long ); \\ printf( \u00eatre coup\u00e9 par le caract\u00e8re \\\\ ); \\ printf( \\n ); \\ } #if 1 #define STR(FONC) str ## FONC #define TOSTR(FONC) #FONC #endif #define carre(x) ((x)*(x)) #define fauxcarre(x) x*x #define MAX 43 int i ; void main ( void ) { i = 4 ; char chaine [ 32 ] = str ; COMMENTAIRE (); printf ( MAX MAXSIZE %d \\n , MAX ); printf ( i vaut %d \\n , i ); printf ( Le resultat de carre(i+1) est %d \\n , carre ( i + 1 )); printf ( Le resultat de fauxcarre(i+1) est %d \\n , fauxcarre ( i + 1 )); #if 1 printf ( %s \\n , STR ( cat )( chaine , TOSTR ( cat ))); #endif } $cc -o pre pre.c $./pre un #define trop long peut \u00eatre coup\u00e9 par le caract\u00e8re \\ MAX MAXSIZE 43 i vaut 4 Le resultat de carre ( i+1 ) est 25 ; Le resultat de fauxcarre ( i+1 ) est 9 strcat $ On remarque sur cet exemple tout l'int\u00e9r\u00eat d'utiliser les parenth\u00e8ses dans les pseudo-fonctions. l'expression carre(i+1) est remplac\u00e9e AVANT g\u00e9n\u00e9ration de code par (i+1)*(i+1) . L'expression fauxcarre(i+1) est remplac\u00e9e par : i+1*i+1 soit par i+i+1 ce qui n'est pas le r\u00e9sultat esp\u00e9r\u00e9. directive # Le # permet de changer le param\u00e8tre en chaine de caract\u00e8re, comme dans la macro de l'exemple pr\u00e9c\u00e9dent TOSTR() . directive ## le ## permet la concat\u00e9nation de 2 mots, comme la macro STR() de l'exemple pr\u00e9c\u00e9dent. Ces deux directives permettent de faire du pseudo objet, ou de simplifier des d\u00e9finitions laborieuses. Compilation conditionnelle. Exemple: /* $cat cond.c */ #include stdio.h #define _UNIX void main ( void ) { #ifdef _UNIX printf ( Un :_UNIX est d\u00e9fini \\n ); #else printf ( Un : _UNIX n est pas d\u00e9fini \\n ); #endif #undef _UNIX #ifdef _UNIX printf ( Deux : _UNIX est d\u00e9fini \\n ); #else printf ( Deux : _UNIX n est pas d\u00e9fini \\n\\ ); #endif } $cond Un : _UNIX est d\u00e9fini Deux : _UNIX n est pas d\u00e9fini $ #undef permet de supprimer une 'variable' pr\u00e9c\u00e9demment d\u00e9finie. #ifdef \u00e9quivalent \u00e0 if #else \u00e9quivalent \u00e0 else Directives de compilation. La directive '#include' permet d'inclure des fichiers. Exemple : #include stdio.h #include myinclude.h Les noms de fichiers entre \\ et > seront cherch\u00e9s dans le r\u00e9pertoire par d\u00e9faut du syst\u00e8me, sur UNIX dans le r\u00e9pertoire /usr/include Les noms de fichiers entre \\\" et \\\" seront cherch\u00e9s dans le r\u00e9pertoire courant ou les r\u00e9pertoires sp\u00e9cifi\u00e9s sur la ligne de commande du compliateur puis dans le(s) r\u00e9pertoire(s) par d\u00e9faut. Les fonctions standards d'entr\u00e9es sorties. Les I/O sont de deux sortes : les I/O de haut niveaux qui sont format\u00e9es et en g\u00e9n\u00e9ral bufferis\u00e9es. fopen(),open() : ouverture fscanf(),read() : lecture formatt\u00e9e, non formatt\u00e9e fprintf(),write() : \u00e9criture format\u00e9e, non formatt\u00e9e fseek(),lseek() : positionnement fclose(),close() : fermeture Les fonctions f... travaillent avec un pointeur sur le descripteur de fichier, les autres avec le num\u00e9ro du descripteur. les entr\u00e9es sorties par d\u00e9faut TROIS Fichiers sont ouverts par d\u00e9faut : stdin : entr\u00e9e standard (clavier par d\u00e9faut) stdout : sortie standard (\u00e9cran par d\u00e9faut) stderr : sortie standard (erreur (\u00e9cran par d\u00e9faut) Ils occupent respectivement les num\u00e9ros de descripteur 0,1 et 2. Ainsi les appels : printf(\\\".... sont \u00e9quivalents \u00e0 fprintf(stdout,\\\"... scanf(\\\".... sont \u00e9quivalents \u00e0 fscanf(stdin,\\\"... Exemple: void main ( void ) { int fd , n ; fd = open ( test , 0 ); /* 0 : Ouverture en lecture */ for ( n = 0 ; read ( fd , c , 1 ) == 1 ; n ++ ); /* parcours du fichier */ close ( fd ); } Se reporter au chapitre 7 du \\\"Kernighan et ritchie\\\"","title":"langage C"},{"location":"langC/#langage-c-niveau-1","text":"SUIVI DES VERSIONS DU DOCUMENT Creation : 1990/10/20 Last change : 2019/10/05 passage en markdown, et aux compilateurs actuelxs. Langage C niveau 1 Pr\u00e9sentation g\u00e9n\u00e9rale Introduction, historique. Un premier programme. Les types et les variables Les variables. Les types de bases. Les bool\u00e9ens. Construction de types. Les tableaux: Les structures: Les classes des variables. auto static extern volatile const register Les constantes. Les op\u00e9rateurs. Les op\u00e9rateurs logiques: Les op\u00e9rateurs arithm\u00e9tiques: Les op\u00e9rateurs sur les bits: Les op\u00e9rateurs sur les pointeurs Autres op\u00e9rateurs: Les Pointeurs Affectation des pointeurs. Les pointeurs et les cha\u00eenes de caract\u00e8res. Proc\u00e9dures et fonctions. Pointeur de fonction. R\u00e9cup\u00e9ration des param\u00e8tres d'une commande. Allocation dynamique. Le Pr\u00e9processeur C : cpp #define directive # directive ## Compilation conditionnelle. Directives de compilation. Les fonctions standards d'entr\u00e9es sorties. les entr\u00e9es sorties par d\u00e9faut","title":"Langage C niveau 1"},{"location":"langC/#presentation-generale","text":"","title":"Pr\u00e9sentation g\u00e9n\u00e9rale"},{"location":"langC/#introduction-historique","text":"Le langage C a \u00e9t\u00e9 d\u00e9velopp\u00e9 par DANIEL RITCHIE au m\u00eame moment que le syst\u00e8me d'exploitation UNIX. Unix a \u00e9t\u00e9 \u00e9crit quasi enti\u00e8rement en langage C (Sur 13000 lignes de codes, seulement 800 sont \u00e9crites en assembleur). Ce n'\u00e9tait pas la premi\u00e8re fois qu'un syst\u00e8me d'exploitation \u00e9tait \u00e9crit dans un langage \u00e9volu\u00e9, mais UNIX est le premier \u00e0 conna\u00eetre une large diffusion. Le langage C est un langage structur\u00e9 de haut niveau ne faisant que peu (ou pas du tout) de contr\u00f4les de type. Exemple : la variable 'c' \u00e9tant d\u00e9fini comme caract\u00e8re 'c = 65;' est correct pour le compilateur C alors que l'\u00e9quivalent en Pascal (Langage de haut niveau tr\u00e8s strict sur les contr\u00f4les de type) ferait hurler le compilateur. Les faiblesses du langage C viennent de l'objectif m\u00eame de ses concepteurs : \u00e9crire le syst\u00e8me UNIX. Il ne comporte aucune instruction d'entr\u00e9es sorties de gestion de la m\u00e9moire etc ... Tous ces m\u00e9canismes sont fournis dans une biblioth\u00e8que de fonctions dans l'environnement syst\u00e8me, heureusement le noyau des fonctions (environ 300 fonctions) est le m\u00eame quelque soit le syst\u00e8me sur lequel on travaille que se soit UNIX ou non. A l'heure actuelle le langage C est normalis\u00e9 par l'ANSI (depuis d\u00e9cembre 1989). Le pr\u00e9sent document pr\u00e9sente les principales difficult\u00e9s du langage C, il ne constitue pas un cours, pour de plus plus amples d\u00e9tails on se reportera au livre \\\"Le langage C de Kerningham et Ritchie.\\\" et si possible \u00e0 la derni\u00e8re version .","title":"Introduction, historique."},{"location":"langC/#un-premier-programme","text":"/* $cat mini.c */ void main ( void ){ } $cc mini.c $a .out $ Rajoutons une ligne gr\u00e2ce \u00e0 l'\u00e9diteur vi. /* $cat mini.c */ ##include sdtio.h void main ( void ) { printf ( Bonjour. \\n ); /* Ceci est un commentaire */ } $cc mini.c $a .out Bonjour. $ Un programme C est form\u00e9 d'une ou plusieurs fonctions. Une seule est obligatoire, celle qui a pour nom 'main'. En fait c'est le point d'entr\u00e9e du programme : c'est la premi\u00e8re fonction que le programme ex\u00e9cute. La fonction 'main' peut se trouver n'importe o\u00f9 dans le programme (en g\u00e9n\u00e9ral au d\u00e9but ou \u00e0 la fin du programme pour des questions de lisibilit\u00e9.). La fonction 'main' ex\u00e9cutera en g\u00e9n\u00e9ral d'autres fonctions soit celles qui proviendront du programme lui-m\u00eame, soit celles qui proviennent de biblioth\u00e8ques, 'printf' est l'une de ces fonctions sa d\u00e9claration se trouve dans le fichier stdio.h qui se trouvent dans le r\u00e9pertoire /usr/include (sous UNIX). Les parenth\u00e8ses qui suivent le nom de la fonction encadrent les param\u00e8tres qui lui sont pass\u00e9s. Les accolades encadrent les instructions \u00e0 ex\u00e9cuter (\u00e9quivalent au Begin End du Pascal). Les commentaires sont encadr\u00e9s par les suites de caract\u00e8res '/*' et '*/'. Un exemple plus cons\u00e9quent : /* min.c */ ##include stdio.h /* * La fonction min renvoie le plus petit des deux entiers qui * lui sont pass\u00e9 en param\u00e8tres. */ int min ( int a , int b ) { return ( a b ? a : b ); } void main . c (){ printf ( le minimum de 4 et 10 est : %d \\n , min ( 10 , 4 )); } $cc -o min min.c $min le minimum de 4 et 10 est : 4 $","title":"Un premier programme."},{"location":"langC/#les-types-et-les-variables","text":"","title":"Les types et les variables"},{"location":"langC/#les-variables","text":"Les variables peuvent \u00eatre d\u00e9finies \u00e0 l'ext\u00e9rieur ou \u00e0 l'int\u00e9rieur des fonctions. A l'int\u00e9rieur des fonctions les variables n'existent qu'\u00e0 partir de l'endroit o\u00f9 elles sont d\u00e9clar\u00e9es. /* $cat var.c */ ##include stdio.h int globale_au_fichier ; void ma_procedure () { int locale_a_la_fonction ; locale_a_la_fonction = 2 ; globale_au_fichier = 4 ; printf ( procedure: locale_a_la_fonction = %d \\n , locale_a_la_fonction ); printf ( procedure: globale_au_fichier = %d \\n , globale_au_fichier ); } void main ( void ) { int locale_a_la_fonction = 1 ; globale_au_fichier = 1 ; ma_procedure (); printf ( main: locale_a_la_fonction = %d \\n , locale_a_la_fonction ); printf ( main: globale_au_fichier = %d \\n , globale_au_fichier ); } Attention le langage C fait la diff\u00e9rence entre majuscules et minuscules, ici les appels \u00e0 bon() et \u00e0 BON() ne sont pas identiques, mais correspondent \u00e0 deux fonctions diff\u00e9rentes. Faire d'autant plus attention que sur certaines implantations du langage C le compilateur fait la diff\u00e9rence mais pas l'\u00e9diteur de liens.","title":"Les variables."},{"location":"langC/#les-types-de-bases","text":"char : caract\u00e8res short : entiers courts int : entiers long : entiers longs float : r\u00e9els double : r\u00e9els double pr\u00e9cision. La taille de ces types (nombre d'octet pris en m\u00e9moire) varie suivant les versions. La seule chose qui vous est assur\u00e9 est que: char = short = int = long = float = double Tous ces types peuvent recevoir le mot cl\u00e9 unsigned pour non sign\u00e9. Exemple : int i ; unsigned char c ; long j ;","title":"Les types de bases."},{"location":"langC/#les-booleens","text":"Il n'y a pas de variables bool\u00e9ennes (au contraire du Pascal) les expressions sont \u00e9valu\u00e9es num\u00e9riquement, un 0 correspond \u00e0 FAUX, tout autre valeur correspond \u00e0 VRAI.","title":"Les bool\u00e9ens."},{"location":"langC/#construction-de-types","text":"[ ] d\u00e9finit les vecteurs et tableaux struct les structures (\u00e9quivalent au record du pascal) union \u00e9quivalent au Record case du Pascal typedef Permet de d\u00e9finir des types * pour les pointeurs.","title":"Construction de types."},{"location":"langC/#les-tableaux","text":"int tab [ 32 ]; /* d\u00e9fini un tableau de 32 entiers */ int * ptr [ 32 ]; /* d\u00e9fini un tableau de 32 pointeurs sur des entiers.*/ /* * tableaux \u00e0 plusieurs dimensions sont d\u00e9finis comme les vecteurs. */ int matrice [ 20 ][ 30 ]; /* d\u00e9fini un tableau de 20 lignes de 30 entiers.*/ Note Il n'est pas possible de borner un tableau le premier \u00e9l\u00e9ment est toujours le num\u00e9ro ZERO. La taille d'un tableau est une constante, elle ne peut \u00eatre d\u00e9finie dynamiquement. le seul cas o\u00f9 la taille peut ne pas \u00eatre d\u00e9finie est dans la d\u00e9claration de variables d'une fonction. DAns le cas d'un tableau multi-dimensionnel seul le premier niveau peut ne pas \u00eatre d\u00e9fini. Exemple : /* parcours_tab.c */ #include stdio.h #define MAXSIZE 32 int tableau [ MAXSIZE ]; int i ; void main ( int argc , char * argv []) { for ( i = 0 ; i = MAXSIZE - 1 ; i ++ ) { tableau [ i ] = i ; /* * parcours de TOUS les \u00e9l\u00e9ments du tableau */ } for ( i = 0 ; i argc ; i ++ ){ printf ( argument %d: %s \\n , i , argv [ i ]); } } On pourrait tout aussi bien \u00e9crire le programme de la mani\u00e8re suivante : /* parcours_tab.c */ #include stdio.h #define MAXSIZE 32 int tableau [ MAXSIZE ]; int i ; void main ( int argc , char ** argv ) { for ( i = 0 ; i = MAXSIZE - 1 ; i ++ ) { tableau [ i ] = i ; /* * parcours de TOUS les \u00e9l\u00e9ments du tableau */ } for ( i = 0 ; i argc ; i ++ ){ printf ( argument %d: %s \\n , i , argv [ i ]); } }","title":"Les tableaux:"},{"location":"langC/#les-structures","text":"Il existe deux mani\u00e8res de d\u00e9finir des structures. struct { int x , y ; /* Coordonn\u00e9es d un pixel \\*/ int couleur ; /* couleur du pixel \\*/ } pix , * p ; Ici on d\u00e9finit 'pix' comme \u00e9tant un structure et 'p' comme \u00e9tant un pointeur sur une structure. La structure d\u00e9finie n'a pas de nom. Les \u00e9l\u00e9ments sont accessibles par : pix.x pix.y pix.couleur struct point { int x , y ; int couleur ; } pix ; struct point * p ; La structure a un nom 'point' qui peut \u00eatre r\u00e9utiliser dans un programme. Un autre moyen est d'utiliser le constructeur de type 'typedef' typedef struct _point { int x , y ; int couleur ; } Point ; /* le type point est d\u00e9fini, CE N EST PAS UNE VARIABLE */ Point pix ; struct _point * p ; le '_point' au niveau de typedef struct _point { n'est pas obligatoire il peut \u00eatre omis dans ce cas. Les deux moyens sont bons, et utile dans certains cas pour faire des structures r\u00e9cursives. /* D\u00e9finition d une structure de type noeud */ typedef struct { noeud * fils_gauche ; /* Interdit de faire cela */ noeud * fils_droit ; int valeur ; } noeud ; /* * D\u00e9finition de 2 types de structures * noeud : objet de type noeud * noeudptr : object de type pointeur vers un objet de type noeud */ typedef struct _noeud { struct _noeud * fils_gauche ; /* On d\u00e9finit le nom _noeud */ struct _noeud * fils_droit ; /* qui ne sera utilis\u00e9 qu ici */ int valeur ; } noeud , * noeudptr ; La mani\u00e8re la plus lisible est d'utiliser la d\u00e9claration avec typedef , de plus elle \u00e9vite de r\u00e9\u00e9crire \u00e0 chaque fois le mot struct .","title":"Les structures:"},{"location":"langC/#les-classes-des-variables","text":"Dans un soucis de simplification, tout les modificateurs ont \u00e9t\u00e9 regroup\u00e9s. Les variables sont caract\u00e9ris\u00e9es par leur types et par leurs classe de stockage, c'est \u00e0 dire leur visibilit\u00e9 : locale ou globale. Les variables ont une classe par d\u00e9faut qui d\u00e9pend de l'endroit o\u00f9 elles sont d\u00e9finies. Les classes sont : auto , static , extern , const , volatile et register .","title":"Les classes des variables."},{"location":"langC/#auto","text":"auto n'est autoris\u00e9 que pour des variables locales \u00e0 int\u00e9rieure d'un bloc d'instruction, c'est la d\u00e9claration utilis\u00e9e par d\u00e9faut. En fait ne sert \u00e0 rien, \u00e0 part forcer l'optimiseur de code \u00e0 ne pas utiliser register .","title":"auto"},{"location":"langC/#static","text":"dans une fonction Hors d'une fonction Sans static Dynamique, locale \u00e0 la fonction globale \u00e0 tous les fichiers Avec static Statique, permanente, visible dans la fonction Statique, permanente, visible dans le fichier.","title":"static"},{"location":"langC/#extern","text":"Permet de faire r\u00e9f\u00e9rence \u00e0 une variable d\u00e9j\u00e0 d\u00e9clar\u00e9e, IL N'Y A PAS RESERVATION DE PLACE MEMOIRE, il est indispensable que la variable soit r\u00e9ellement d\u00e9clar\u00e9e dans un autre fichier ou module du programme, sinon il y aura une erreur lors de l'\u00e9dition de liens. En g\u00e9n\u00e9ral, on peut se dispenser du mot cl\u00e9 extern mais certains compilateurs veulent que les variables ne soient d\u00e9clar\u00e9es qu'une seule fois dans tout le programme.","title":"extern"},{"location":"langC/#volatile","text":"Permet de dire au compilateur de ne pas faire d'optimisation sur la variable. la variable peut \u00eatre mise \u00e0 jour \u00e0 tout moment par une autre tache (thread).","title":"volatile"},{"location":"langC/#const","text":"const permet d'\u00e9viter la modification des variables. Elles peuvent juste \u00eatre initialis\u00e9es \u00e0 la d\u00e9claration. Permet de g\u00e9n\u00e9rer des erreurs de compilation si il y a une terntative de modfication de la variable. Example #include stdio.h size_t longueur_de_chaine ( const char chaine [] ) { register size_t longueur ; for ( longueur = 0 ; chaine [ longueur ]; longueur ++ ); return longueur ; } void main ( int argc , char ** argv ) { int i ; for ( i = 0 ; i argc ; i ++ ){ printf ( argument %2d - longueur=%3ld - %s \\n , i , longueur_de_chaine ( * ( argv + i )), argv [ i ]); } }","title":"const"},{"location":"langC/#register","text":"Demande que la variable soit rang\u00e9e dans un registre dans la mesure du possible, c'est \u00e0 dire qu'il y ait un registre de libre et que la taille de la variable soit inf\u00e9rieure ou \u00e9gale \u00e0 celle du registre de la machine. Ceci est surtout utilis\u00e9 pour les variables de boucles et acc\u00e9l\u00e8re de mani\u00e8re sensible l'ex\u00e9cution de programme. Exemple : /* sans.c */ void main ( void ) { int i , j , s ; for ( i = 1 ; i = 1000 ; i ++ ) { s = 0 ; for ( j = 0 ; j 10000 ; j += i ) s += j ; } } /* $cat avec.c */ void main ( void ) { register int i , j , s ; for ( i = 1 ; i = 1000 ; i ++ ) { s = 0 ; for ( j = 0 ; j 10000 ; j += i ) s += j ; } } $cc -o sans sans.c $cc -o avec avec.c $time sans 0 .8 real 0 .7 user 0 .0 sys $time avec 0 .7 real 0 .3 user 0 .0 sys $ Avec les machines actuelles il faudra peut \u00eatre rajouter deux 0 dans les boucles pour voir quelque chose.","title":"register"},{"location":"langC/#les-constantes","text":"Les constantes peuvent \u00eatre de type : entier : 12 , 012 , 0xff , 0L r\u00e9el : 35.2 , .78e-23 caract\u00e8re : 'c' , '\\n' , '\\007' cha\u00eene : \\\"\\0x07Chaine qui \\\\\"sonne\\\\\" et va \u00e0 la ligne \\n\\\" Les constantes enti\u00e8res peuvent \u00eatre en base 10,base 8 (Premier chiffre est un 0 ) ou en base 16 (commen\u00e7ant par 0x). le suffixe L indique une constante de type long. Le caract\u00e8re ' joue le r\u00f4le de caract\u00e8re d'\u00e9chappement, il permet de repr\u00e9senter certains caract\u00e8res: \\n fin de ligne \\t tabulation \\b backspace \\r retour chariot \\f form feed (saut de page) \\\\ \\ \\\" \" \\' ' \\0 le caract\u00e8re de code ASCII z\u00e9ro NULL Le caract\u00e8re \\ permet d' \u00e9chapper un caract\u00e8re dans les d\u00e9finitions de constantes caract\u00e8re ainsi que dans les constantes cha\u00eene. Exemple cha\u00eene form\u00e9e de deux guillemets : \"\\\"\\\"\" .","title":"Les constantes."},{"location":"langC/#les-operateurs","text":"","title":"Les op\u00e9rateurs."},{"location":"langC/#les-operateurs-logiques","text":"\\ inf\u00e9rieur sup\u00e9rieur => Sup\u00e9rieur ou \u00e9gal = inf\u00e9rieur ou \u00e9gal == \u00e9gal != diff\u00e9rent ! non logique et logique || ou logique","title":"Les op\u00e9rateurs logiques:"},{"location":"langC/#les-operateurs-arithmetiques","text":"+ plus - moins * multiplication / division % modulo ++ auto-incr\u00e9mentation (pr\u00e9fixe '++var'ou postfixe 'var++') -- auto-d\u00e9cr\u00e9mentation (idem)","title":"Les op\u00e9rateurs arithm\u00e9tiques:"},{"location":"langC/#les-operateurs-sur-les-bits","text":"~ compl\u00e9ment et | ou ^ ou exclusif d\u00e9calage de bits vers la droite d\u00e9calage de bits vers la gauche Remarque pour les op\u00e9rateurs arithm\u00e9tique et sur les bits on notera le raccourci suivant : a (op)=b \u00e9quivaut \u00e0 a = a (op) b Ceci est un raccourci d'\u00e9criture mais correspond aussi \u00e0 une optimisation du code du programme.","title":"Les op\u00e9rateurs sur les bits:"},{"location":"langC/#les-operateurs-sur-les-pointeurs","text":"* indirection adresse d'une variable - acc\u00e8s aux champs d'une structure ( p->x est \u00e9quivalent \u00e0 (*p).c ) Certains op\u00e9rateurs acceptent des pointeurs : + , - , ++ , -- op\u00e9rateurs arithm\u00e9tiques * , -> indirections (TYPE) conversion de type , , = , = , == , != op\u00e9rateurs de comparaison Exemple si p est un pointeur sur un objet et i un entier p + i est l'adresse du i-\u00e8me objet suivant l'objet point\u00e9 par p","title":"Les op\u00e9rateurs sur les pointeurs"},{"location":"langC/#autres-operateurs","text":"(TYPE) Op\u00e9rateur unaire permettant de convertir une variable dans le type TYPE . sizeof(OBJET) Taille de l'objet en octets (OBJET peut \u00eatre une variable ou le type d'une variable) = Affectation simple. e ? e1 : e2 Expression conditionnelle sa valeur est e1 si e est vrai e2 sinon. e1,e2,...,eq Liste d'expressions \u00e9valu\u00e9es s\u00e9quentiellement de e1 puis e2 jusqu'\u00e0 eq, la valeur de la liste vaut eq Exemple : (i=2,j=i++,5*j-i) a pour valeur 7, de plus i vaut 3 et j vaut 2","title":"Autres op\u00e9rateurs:"},{"location":"langC/#les-pointeurs","text":"Une variable de type pointeur est une variable contenant une adresse. On peut d\u00e9finir des pointeurs sur des variables de type de base ou sur des variables construites \u00e0 partir des types de bases. Le type pointeur d'un objet de type 'TYPE' est : 'TYPE *' . Exemple : int * p ; /* Pointeur sur un entier */ struct _point * pixptr ; /* Pointeur sur un objet dont le type est struct _point */ L'objet point\u00e9 par le pointeur 'p' est not\u00e9 : '*p' , l'adresse d'un objet 'q' est not\u00e9e ' q '; Exemple : (sur les versions actuelles peut donner un warning \u00e0 la compilation, ne pas en tenir compte) /* $cat demoptr.c */ #include stdio.h void main ( void ){ int i ; int * p ; char * ch ; i = 10 ; p = i ; /* p contient l adresse de la variable i */ ch = Ceci est une cha\u00eene. \\n ; /* * ch contient l adresse de la cha\u00eene qui sera rang\u00e9e dans le * segment des donn\u00e9es au moment de la g\u00e9n\u00e9ration de code. Le * d\u00e9limiteur de cha\u00eene EST rajout\u00e9 au moment de la g\u00e9n\u00e9ration de * code. */ printf ( Valeur du contenu \u00e0 l adresse de p est %d \\n , * p ); printf ( %s , ch ); printf ( ch ); /* donne la m\u00eame chose que la ligne pr\u00e9c\u00e9dente */ } $ cc -o demoptr.e demoptr.c $ $ ./demoptr.e Valeur du contenu \u00e0 l adresse de p est 10 Ceci est une cha\u00eene. Ceci est une cha\u00eene. $ Les op\u00e9rations sur les pointeurs sont : L'affectation simple : = Les op\u00e9rations arithm\u00e9tiques : + , - , ++ , -- L'indirection : * , -> Les conversions de type et le calcul de la taille. Les op\u00e9rateurs de comparaison.","title":"Les Pointeurs"},{"location":"langC/#affectation-des-pointeurs","text":"La d\u00e9claration d'un pointeur r\u00e9serve de la place pour le pointeur ET NON pour l'objet point\u00e9. Exemple : /* $cat faux.c */ void main ( void ) { int * p ; /* R\u00e9servation de place pour le pointeur uniquement */ * p = 120 ; /* Pas de r\u00e9servation de place pour l entier */ } $ cc -o faux faux.c $ ./faux Bus error ( core dumped ) $ Attention la diff\u00e9rence de type entre les deux membres lors d'une affectation n'est pas trait\u00e9e comme une erreur fatale mais donne lieu \u00e0 un 'warning'. Exemple : /* $cat demoptr2.c */ #include stdio.h void main ( void ) { long i ; long * p ; char * c ; i = p ; /*Donne lieu \u00e0 un warning mais pas une erreur fatale */ i = ( long ) p ; /* * Bonne m\u00e9thode ne donne lieu \u00e0 aucun commentaire de la part * du compilateur et l on sait ce que l on fait !!!! */ i = 0x41424344 ; p = i ; c = ( char * ) p ; /* La valeur du pointeur p est convertie en pointeur sur * caract\u00e8re */ printf ( %c \\n , * c ); /* Affiche le contenu du premier octet de la variable i ou le dernier*/ } La r\u00e8gle \u00e0 appliquer est de toujours \u00e9crire des expressions homog\u00e8nes pour \u00e9viter les warnings, de plus l'on sait ce que l'on fait !!!! (En principe)","title":"Affectation des pointeurs."},{"location":"langC/#les-pointeurs-et-les-chaines-de-caracteres","text":"Une cha\u00eene de caract\u00e8res en C est est une suite d'octets se terminant par le caract\u00e8re de code ASCII z\u00e9ro (NULL). Ainsi \\\"chaine\\\" est une constante ayant pour valeur l'adresse d'un zone m\u00e9moire dont les 7 premiers octets ont pour valeur 'c' 'h' 'a' 'i' 'n' 'e' ET '\\0'. Exemple : /* $cat demoptr3.c */ #include stdio.h char * p , c ; int i ; void main ( void ) { p = ABCDEFGHIJKLMNO ; c = * ( p + 2 ); /* c contient le caract\u00e8re C . */ i = * ((( int * ) p ) + 1 ); printf ( sizeof(int*) = %ld \\n , sizeof ( int * )); printf ( sizeof(int) = %ld \\n , sizeof ( int )); printf ( i = %x \\n , i ); } Regardons la derni\u00e8re expression de plus pr\u00e9s : (int *) p : p est un pointeur sur des caract\u00e8res il est converti en pointeur sur un entier. ((int *) p) + 1 : On obtient l'adresse de l'entier suivant, le d\u00e9placement d\u00e9pend de l'impl\u00e9mentation sur la machine du langage, en pratique on se d\u00e9place de 2, 4 ou 8 octets *(((int *) p) + 1) : On obtient la valeur de l'entier suivant (0x45464748 ou 0x48474645 suivant la taille des indiens). On peut construire une cha\u00eene de caract\u00e8res de diff\u00e9rentes mani\u00e8res: En utilisant les guillemets, la caract\u00e8re de fin de cha\u00eene (NULL) est automatiquement rajout\u00e9. En remplissant \u00e0 la main les zones d'un tableau. En utilisant des fonctions de la biblioth\u00e8que standard du C tel que strcpy() , strcat() ... Exemple: /* $cat chaine.c */ #include stdio.h #include string.h void main ( void ) { char ch [ 10 ], chh [ 10 ]; char * chaine ; chaine = ijklmn ; /* 1\u00e8re m\u00e9thode */ ch [ 0 ] = a ; /* 2\u00e8me m\u00e9thode */ ch [ 1 ] = b ; ch [ 2 ] = \\0 ; ( void ) strcpy ( chh , cdefgh ); /* 3\u00e8me m\u00e9thode */ ( void ) strcat ( ch , chh ); printf ( chaine contient : %s \\n , chaine ); printf ( chh contient : %s \\n , chh ); printf ( ch contient : %s \\n , ch ); ch [ 4 ] = \\0 ; printf ( La chaine S ARRETE au premier caract\u00e8re \\\\ 0 \\n ); printf ( ch vaut maintenant : %s \\n , ch ); } A l'ex\u00e9cution : $ cc chaine.c $ ./a.out chaine contient : ijklmn chh contient : cdefgh ch contient : abcdefgh La chaine S ARRETE au premier caract\u00e8re \\0 ch vaut maintenant : abcd $","title":"Les pointeurs et les cha\u00eenes de caract\u00e8res."},{"location":"langC/#procedures-et-fonctions","text":"En C il n'y a pas de diff\u00e9rence entre une proc\u00e9dure et une fonction, par d\u00e9faut une fonction retourne un entier. Une proc\u00e9dure \u00e9tant une fonction qui ne retourne pas de valeur. Une fonction peut \u00e9galement retourner l'un des types de base ou un pointeur. Attention Dans une fonction les variables sont par d\u00e9faut de classe 'auto', c'est \u00e0 dire dynamique. En fait elles sont allou\u00e9es dans la pile et disparaissent apr\u00e8s l'ex\u00e9cution de la fonction. En C les param\u00e8tres d'une fonction sont tous pass\u00e9s par valeurs. Si l'on veut passer des param\u00e8tres par r\u00e9f\u00e9rence il est n\u00e9cessaire de passer l'adresse de la variable. Exemple : /* $cat para.c*/ #include stdio.h /* La fonction swap1 ne marche pas */ void swap1 ( int a , int b ) { int temp ; temp = a ; a = b ; b = temp ; } /* La fonction swap marche. */ void swap ( int * a , int * b ) { int temp ; temp = * a ; * a = * b ; * b = temp ; } void main ( void ) { int a , b ; a = 10 ; b = 5 ; printf ( Les valeurs de a et b sont a=%d , b=%d \\n , a , b ); swap1 ( a , b ); printf ( la fonction swap1 ne marche pas a=%d , b = %d \\n , a , b ); swap ( a , b ); printf ( la focntion swap marche a=%d , b = %d \\n , a , b ); }","title":"Proc\u00e9dures et fonctions."},{"location":"langC/#pointeur-de-fonction","text":"On peut d\u00e9finir des fonctions sur n'importe quel type de variables; on peut aussi d\u00e9clarer des pointeurs sur des fonctions. Exemple: /* $cat foncptr.c */ ##include stdio.h typedef int ( * adfonc ) ( int i ); /* declare adfonc comme pointeur de fonction retournant un entier. */ int f0 ( int i ) { printf ( La valeur du param\u00e8tre de f0 est %d \\n , i ); } int f1 ( int i ) { printf ( La valeur du param\u00e8tre de f1 est %d \\n , i ); } int f2 ( int i ) { printf ( La valeur du param\u00e8tre de f2 est %d \\n , i ); } void main ( void ) { int i ; adfonc tab [ 3 ] = { f0 , f1 , f2 }; for ( i = 0 ; i 3 ; i ++ ){ ( * tab [ i ])( i ); } } $ cc -o foncptr foncptr.c $ ./foncptr La valeur du param\u00e8tre de f0 est 0 La valeur du param\u00e8tre de f1 est 1 La valeur du param\u00e8tre de f2 est 2 $ Note On \u00e9crit tab[0] = f0; et non tab[0] = car f0 est une constante dont la valeur est l'adresse de la fonction f0() tout comme pour un tableau o\u00f9 t et t[0] sont \u00e9quivalents.","title":"Pointeur de fonction."},{"location":"langC/#recuperation-des-parametres-dune-commande","text":"La plupart des commandes UNIX demandent des param\u00e8tres pour s'ex\u00e9cuter. De m\u00eame, il est possible de r\u00e9cup\u00e9rer des param\u00e8tres pass\u00e9s sur la ligne de commande pour nos propres programmes C. Exemple: /* cat litarg.c */ #include stdio.h void main ( int argc , char ** argv ) { int i ; for ( i = 0 ; i argc ; i ++ ) printf ( Argument n\u00b0 %d est %s \\n , i , argv [ i ]); } $cc -o arg litarg.c $ ./arg bonjour cc -o argument Argument n\u00b0 0 est arg Argument n\u00b0 1 est bonjour Argument n\u00b0 2 est cc Argument n\u00b0 3 est -o Argument n\u00b0 4 est argument $ $ ./arg Argument n\u00b0 0 est arg $ On remarque qu'un programme poss\u00e8de au moins un argument : le nom du programme. Note Si vous travaillez sous UNIX Essayer 'arg *' cela vous donnera la liste des fichiers sous votre directory courante. $ ./arg *.c Argument n\u00b0 0 est arg Argument n\u00b0 1 est lit_arg.c Argument n\u00b0 2 est foncptr.c Argument n\u00b0 3 est para.c $ Sous UNIX (ou DOS) il est possible de lire la table d'environnement pass\u00e9e au programme; la d\u00e9claration est la suivante : /* $cat env.c */ ##include stdio.h void main ( int argc , char ** argv , char ** envp ) { int i ; for ( i = 0 ; envp [ i ]; i ++ ) printf ( %s \\n , envp [ i ]); /* La condition est fausse quand envp[i] vaut NULL (c.\u00e0.d 0) */ } $env PATH = :/usr/bin:/bin HOME = /usr/alfred TZ = GMT0 TERM = VT100 $ Permet de lire la table d'environnement.","title":"R\u00e9cup\u00e9ration des param\u00e8tres d'une commande."},{"location":"langC/#allocation-dynamique","text":"L'allocation dynamique nous permet de r\u00e9server de l'espace m\u00e9moire durant l'ex\u00e9cution du programme. Exemple sur des listes chain\u00e9es : /* cat liste.c */ ##include stdio.h /* Fonctions standards d entr\u00e9es sorties */ ##include stdlib.h /* pour malloc */ ##include string.h /* Fonctions de manipulations de chaines */ ##define MAXSIZE 32 typedef struct _LISTE { char nom [ MAXSIZE ]; struct _LISTE * suivant ; } LISTE , * LISTEPTR ; LISTEPTR deblist = NULL ; /* pointeur initialis\u00e9 \u00e0 vide */ LISTEPTR finlist = NULL ; /* * Fonction d ajout d un \u00e9l\u00e9ment */ LISTEPTR ajoute ( char * s ) { LISTEPTR p ; /* Allocation d une nouvelle structure */ p = ( LISTEPTR ) malloc ( sizeof ( LISTE )); /* mise \u00e0 0 de la partie memoire obtenue */ ( void ) memset ( p , sizeof ( LISTE ), 0 ); /* si p vaut NULL il n y a plus de place */ if ( p == NULL ) { fprintf ( stderr , D\u00e9passement capacit\u00e9 m\u00e9moire !! \\n ); exit ( 1 ); } if ( deblist == NULL ){ deblist = finlist = p ; } else { finlist - suivant = p ; finlist = p ; finlist - suivant = NULL ; } /* on recopie en gardant un ocet pour le caratere de fon de chaine */ strncpy ( finlist - nom , s , MAXSIZE - 1 ); return finlist ; } /* * Supprimme un \u00e9l\u00e9ment de la liste */ void supprime ( LISTEPTR pl ) { LISTEPTR p , q ; if ( pl == NULL ) return ; /* Si chaine vide on ne fait rien */ p = q = deblist ; /* Initialisation de p et q */ if ( pl == deblist ){ deblist = deblist - suivant ; if ( pl == finlist ) finlist = NULL ; } else { do { /* Parcours de la liste */ q = p ; /* jusqu \u00e0 pl */ p = p - suivant ; } while (( q - suivant != pl ) || ( p == NULL )); if ( p == NULL ) return ; /* Si pl n est pas dans la liste */ q - suivant = p - suivant ; if ( q - suivant == NULL ) /* si c est le dernier element */ finlist = q ; } free ( pl ); } void main ( void ) { LISTEPTR p ; LISTEPTR curptr = NULL ; ( void ) ajoute ( alfred ); curptr = ajoute ( michel ); ( void ) ajoute ( robert ); ( void ) ajoute ( un tres long nom de prenom qui depasse les 32 caract\u00e8res ); /* On affiche la liste */ for ( p = deblist ; p ; p = p - suivant ) printf ( %s \\n , p - nom ); supprime ( curptr ); /* On supprime michel*/ printf ( michel est supprim\u00e9 \\n ); for ( p = deblist ; p ; p = p - suivant ) printf ( %s \\n , p - nom ); } $ $./liste alfred michel robert michel est supprim\u00e9 alfred robert $ La fonction d'allocation de m\u00e9moire est 'malloc' elle alloue le nombre d'octets pass\u00e9 en param\u00e8tre. Attention toujours passer par la fonction sizeof() pour determiner la taille d'une structure, ceci pour des probl\u00e8mes de portabilit\u00e9. Exemple : /* mauvais.c */ void main ( void ) { int * p ; p = ( int * ) malloc ( 2 ); * p = 12 * 256 * 256 ; } /* bon.c */ void main ( void ) { int * p ; p = ( int * ) malloc ( sizeof ( int )); * p = 12 * 256 * 256 ; } Le programme 'mauvais.c' marche sur DOS o\u00f9 la taille des entiers est de 2 octets; mais pas sur d'autres machines o\u00f9 la taille des entiers est de 4 octets (syst\u00e8me d'exploitation 32 bits).","title":"Allocation dynamique."},{"location":"langC/#le-preprocesseur-c-cpp","text":"Le pr\u00e9processeur permet de faire de la compilation conditionnelle, de d\u00e9finir des macros (comme en assembleur), et de donner des directives de compilation. Toutes ces instructions commencent par le caract\u00e8re #. Certains compilateurs tiennent absolument \u00e0 ce que ce soit le premier caract\u00e8re d'une ligne. Attention Toutes les directives (commen\u00e7ant par #) ne se terminent pas par un point-virgule.","title":"Le Pr\u00e9processeur C : cpp"},{"location":"langC/#35define","text":"Permet de d\u00e9finir des entit\u00e9s des macros instructions. Une ligne trop longue peut \u00eatre coup\u00e9e par le caract\u00e8re d'\u00e9chappement \\ . Exemple : #define _UNIX l'entit\u00e9 _UNIX est d\u00e9finie. #define MAX 43 Dans tout le programme suivant la d\u00e9finition MAX sera remplac\u00e9 par 43 #include stdio.h #include string.h #define COMMENTAIRE() { \\ printf( Un #define trop long ); \\ printf( \u00eatre coup\u00e9 par le caract\u00e8re \\\\ ); \\ printf( \\n ); \\ } #if 1 #define STR(FONC) str ## FONC #define TOSTR(FONC) #FONC #endif #define carre(x) ((x)*(x)) #define fauxcarre(x) x*x #define MAX 43 int i ; void main ( void ) { i = 4 ; char chaine [ 32 ] = str ; COMMENTAIRE (); printf ( MAX MAXSIZE %d \\n , MAX ); printf ( i vaut %d \\n , i ); printf ( Le resultat de carre(i+1) est %d \\n , carre ( i + 1 )); printf ( Le resultat de fauxcarre(i+1) est %d \\n , fauxcarre ( i + 1 )); #if 1 printf ( %s \\n , STR ( cat )( chaine , TOSTR ( cat ))); #endif } $cc -o pre pre.c $./pre un #define trop long peut \u00eatre coup\u00e9 par le caract\u00e8re \\ MAX MAXSIZE 43 i vaut 4 Le resultat de carre ( i+1 ) est 25 ; Le resultat de fauxcarre ( i+1 ) est 9 strcat $ On remarque sur cet exemple tout l'int\u00e9r\u00eat d'utiliser les parenth\u00e8ses dans les pseudo-fonctions. l'expression carre(i+1) est remplac\u00e9e AVANT g\u00e9n\u00e9ration de code par (i+1)*(i+1) . L'expression fauxcarre(i+1) est remplac\u00e9e par : i+1*i+1 soit par i+i+1 ce qui n'est pas le r\u00e9sultat esp\u00e9r\u00e9.","title":"#define"},{"location":"langC/#directive-35","text":"Le # permet de changer le param\u00e8tre en chaine de caract\u00e8re, comme dans la macro de l'exemple pr\u00e9c\u00e9dent TOSTR() .","title":"directive #"},{"location":"langC/#directive-3535","text":"le ## permet la concat\u00e9nation de 2 mots, comme la macro STR() de l'exemple pr\u00e9c\u00e9dent. Ces deux directives permettent de faire du pseudo objet, ou de simplifier des d\u00e9finitions laborieuses.","title":"directive ##"},{"location":"langC/#compilation-conditionnelle","text":"Exemple: /* $cat cond.c */ #include stdio.h #define _UNIX void main ( void ) { #ifdef _UNIX printf ( Un :_UNIX est d\u00e9fini \\n ); #else printf ( Un : _UNIX n est pas d\u00e9fini \\n ); #endif #undef _UNIX #ifdef _UNIX printf ( Deux : _UNIX est d\u00e9fini \\n ); #else printf ( Deux : _UNIX n est pas d\u00e9fini \\n\\ ); #endif } $cond Un : _UNIX est d\u00e9fini Deux : _UNIX n est pas d\u00e9fini $ #undef permet de supprimer une 'variable' pr\u00e9c\u00e9demment d\u00e9finie. #ifdef \u00e9quivalent \u00e0 if #else \u00e9quivalent \u00e0 else","title":"Compilation conditionnelle."},{"location":"langC/#directives-de-compilation","text":"La directive '#include' permet d'inclure des fichiers. Exemple : #include stdio.h #include myinclude.h Les noms de fichiers entre \\ et > seront cherch\u00e9s dans le r\u00e9pertoire par d\u00e9faut du syst\u00e8me, sur UNIX dans le r\u00e9pertoire /usr/include Les noms de fichiers entre \\\" et \\\" seront cherch\u00e9s dans le r\u00e9pertoire courant ou les r\u00e9pertoires sp\u00e9cifi\u00e9s sur la ligne de commande du compliateur puis dans le(s) r\u00e9pertoire(s) par d\u00e9faut.","title":"Directives de compilation."},{"location":"langC/#les-fonctions-standards-dentrees-sorties","text":"Les I/O sont de deux sortes : les I/O de haut niveaux qui sont format\u00e9es et en g\u00e9n\u00e9ral bufferis\u00e9es. fopen(),open() : ouverture fscanf(),read() : lecture formatt\u00e9e, non formatt\u00e9e fprintf(),write() : \u00e9criture format\u00e9e, non formatt\u00e9e fseek(),lseek() : positionnement fclose(),close() : fermeture Les fonctions f... travaillent avec un pointeur sur le descripteur de fichier, les autres avec le num\u00e9ro du descripteur.","title":"Les fonctions standards d'entr\u00e9es sorties."},{"location":"langC/#les-entrees-sorties-par-defaut","text":"TROIS Fichiers sont ouverts par d\u00e9faut : stdin : entr\u00e9e standard (clavier par d\u00e9faut) stdout : sortie standard (\u00e9cran par d\u00e9faut) stderr : sortie standard (erreur (\u00e9cran par d\u00e9faut) Ils occupent respectivement les num\u00e9ros de descripteur 0,1 et 2. Ainsi les appels : printf(\\\".... sont \u00e9quivalents \u00e0 fprintf(stdout,\\\"... scanf(\\\".... sont \u00e9quivalents \u00e0 fscanf(stdin,\\\"... Exemple: void main ( void ) { int fd , n ; fd = open ( test , 0 ); /* 0 : Ouverture en lecture */ for ( n = 0 ; read ( fd , c , 1 ) == 1 ; n ++ ); /* parcours du fichier */ close ( fd ); } Se reporter au chapitre 7 du \\\"Kernighan et ritchie\\\"","title":"les entr\u00e9es sorties par d\u00e9faut"},{"location":"unix/","text":"Syst\u00e8me UNIX niveau 1 SUIVI DES VERSIONS DU DOCUMENT Creation : 1988/01/20 Last changes : 2019/10/07 corrections mineures 2018/09/07 passage en markdown Syst\u00e8me UNIX niveau 1 Pr\u00e9face Notations Avertissement. Introduction Qu'est ce que UNIX Historique Avant Linux Description g\u00e9n\u00e9rale Principales caract\u00e9ristiques du syst\u00e8me UNIX Portabilit\u00e9 Premier contact avec UNIX Session utilisateur Proc\u00e9dure d'entr\u00e9e sous UNIX Manipulations des commandes UNIX Proc\u00e9dure d'arr\u00eat d'une commande Proc\u00e9dure de sortie d'UNIX Premi\u00e8res Commandes. La commande \"banner\" La commande \"logname\" La commande \"who\" La commande \"passwd\" La commande \"echo\" La commande \"man\" Le shell Le syst\u00e8me de fichiers Qu'est ce qu'un fichier Pr\u00e9sentation g\u00e9n\u00e9rale R\u00e9f\u00e9rence des fichiers et r\u00e9pertoire de travail La protection des fichiers Les commandes de manipulations de fichiers. La commande \"pwd\" La commande \"cd\" La commande \"ls\" La commande \"cat\" La commande \"cp\" La commande \"ln\" La commande \"mv\" La commande \"rm\" La commande \"mkdir\" La commande \"rmdir\" Modification des caract\u00e9ristiques d'un i-node La commande \"chgrp\" La commande \"chown\" La commande \"chmod\" Les entr\u00e9es-sorties, M\u00e9canismes de redirection La commande \"wc\" Fichiers et processus G\u00e9n\u00e9ralit\u00e9s et pr\u00e9sentation La commande \"ps\" Le Shell Lancement d'un processus en arri\u00e8re plan La Commande \"nohup\" La commande \"wait\" La commande \"nice\" La commande \"at\" Destruction d'un processus La commande \"kill\" Editeur de texte vi Introduction \u00e0 vi Appel de l'\u00e9diteur. Les commandes de vi La touche Esc Pour sortir de l'\u00e9diteur Commandes G\u00e9n\u00e9rales D\u00e9placement du curseur Commandes de suppression de texte. Commandes de recherche (cha\u00eene de caract\u00e8res) Commandes d'insertion Commandes de modification Commandes de r\u00e9cup\u00e9ration Quelques commandes particuli\u00e8res Conclusions Pipelines (tubes) Introduction Les filtres. La commande sort La commande \"grep\" tubes et redirections d'I/O Quelques filtres usuels La commande \"pr\" La commande \"paste\" La commande \"pg\" La commande \"lp\" Le Shell,Programmation et Environnement L'environnement. La commande \"set\" La commande \"export\" La commande \"env\" Affectation des variables Les caract\u00e8res sp\u00e9ciaux Les noms implicites de fichiers Le fichier .profile Introduction \u00e0 la programmation en shell Communications entre utilisateurs Introduction Messagerie. La commande \"mail\" La commande \"mailx\" Le journal de bord. La commande \"news\" La conversation en temps r\u00e9el La commande \"mesg\" La commande \"write\" Sauvegarde et archivage des fichiers. La commande \"find\" La commande \"cpio\" cpio -p directory cpio -o (output = sortie) cpio -i (input = entr\u00e9e) Les options: La commande \"tar\" La commande \"ar\" La commande \"cmp\" Commandes additionnelles La commande \"crypt\" La commande \"od\" La commande \"touch\" La commande \"split\" Les commandes d'administration du syst\u00e8me. La commande \"su\" La commande \"sar\": La commande \"sysadm\" La commande de configuration du terminal \"stty\" Les modes de contr\u00f4les Les modes d'entr\u00e9e Les modes de sortie Les modes locaux Pr\u00e9face Notations Durant tout ce cours nous utiliserons les notations suivantes : Pour indiquer qu'il faut appuyer sur la touche \"retour chariot\" ou \"Enter\" nous noterons \" cr \" . Pour indiquer \"control d\" : Appui simultan\u00e9 de la touche \"Control\" et de la touche \" d \" nous noterons \" Ctrl-d \". Pour la description de la syntaxe d'une commande, les termes optionnels seront plac\u00e9s entre crochets :\" [Termes optionnels] \". Les noms des fichiers seront mis entre guillemets. Avertissement. Ce cours ne constitue pas un manuel UNIX, nous ne pr\u00e9senterons pas toutes les commandes UNIX, mais uniquement les principales pour d\u00e9marrer. Nous ne ferons pas une description exhaustive des commandes, mais donnerons uniquement la syntaxe et les options les plus couramment utilis\u00e9es. Pour tout compl\u00e9ment d'information, se reporter aux manuels d'Unix fournis avec le mat\u00e9riel. Introduction Qu'est ce que UNIX UNIX est un syst\u00e8me d'exploitation, multi-taches, multi-utilisateurs. Il se situe entre l'utilisateur et la machine. Utilisateur Syst\u00e8me d'exploitation Hardware de la machine Le syst\u00e8me est charg\u00e9 du partage \u00e9quitable des ressources de la machine entre chaque utilisateur. Le syst\u00e8me d'exploitation n\u00e9gocie entre les d\u00e9sirs de l'utilisateur et les ressources ou les performances de la machine. Les demandes : ex\u00e9cuter des commandes. cr\u00e9er des fichiers. entrer dans un r\u00e9seau. etc ... Les ressources : l'unit\u00e9 centrale, la m\u00e9moires, les Disques, le r\u00e9seau, etc... Historique Le syst\u00e8me d'exploitation UNIX a \u00e9t\u00e9 d\u00e9velopp\u00e9 par les laboratoires BELL, d\u00e9pendant de AT T (American Telephone Telegraph), l'un des plus grands centres de recherche au monde. Son cr\u00e9ateur est KEN THOMPSON, il en a assur\u00e9 la conception en 1969. Depuis cette date, beaucoup de chercheurs, d'ing\u00e9nieurs ont contribu\u00e9 \u00e0 son enrichissement, \u00e0 son \u00e9volution. Le d\u00e9veloppement du langage C par DENNIS RITCHIE a permis l'\u00e9criture d'une version dans ce langage de haut niveau, par cons\u00e9quent portable \u00e0 priori sur tout type de machine disposant d'un compilateur C. *\"SYSTEM 3\" est apparu en 1981, et marque la double volont\u00e9 de AT T de: Se lancer dans une action commerciale de grande envergure, r\u00e9agir contre les d\u00e9rives des diff\u00e9rents portages d'UNIX, et conduisant \u00e0 certaines incompatibilit\u00e9s. * La derni\u00e8re version, \"SYSTEM V\", est le fruit d'efforts importants durant plusieurs ann\u00e9es, entrepris par AT T et par l'universit\u00e9 de BERKELEY, en Californie, principalement. Les domaines concern\u00e9s sont avant tout la gestion des fichiers et la fiabilit\u00e9 d'Unix. \"SYSTEM V\" apparu en 1983, marque la volont\u00e9 de AT T d'imposer cette version, tant aux constructeurs d'ordinateurs qu'aux soci\u00e9t\u00e9s de logiciels qui se rallient massivement \u00e0 ce standard, tout en r\u00e9alisant un certain nombre d'ajouts li\u00e9s \u00e0 des \u00e9quipements particuliers et/ou \u00e0 des logiciels existants. Ces diff\u00e9rences sont valid\u00e9es par AT T. Il existe une quarantaine de \"versions diff\u00e9rentes\" du syst\u00e8me UNIX... Ce nombre, inqui\u00e9tant de prime abord lorsque l'on a des soucis de portabilit\u00e9, de compatibilit\u00e9, que signifie-t-il au juste? pourquoi toutes ces versions? Qu'est-ce-que cela cache? Pourquoi toutes ces versions ? Il convient d'aborder ce point selon deux axes: historique et commercial. Avant Linux De nos jours, Unix est plut\u00f4t connu via Linux et ses multiples distributions. UNIX est apparu en 1969. UNIX a \u00e9volu\u00e9 dans le temps et les diff\u00e9rentes versions de r\u00e9f\u00e9rence (d\u00e9nomm\u00e9es dans tout ce qui suit AT T-UNIX), ont marqu\u00e9 les grandes \u00e9tapes de cette \u00e9volution: Version 5 (1973) Version 6 (1975) Version 7 (1979) Syst\u00e8me III (1981) Syst\u00e8me V (1983) Chacune de ces versions techniques au-del\u00e0 de la \"Version 7\" a donn\u00e9 naissance \u00e0 des versions commerciales. AT T, qui est propri\u00e9taire de la marque UNIX (UNIX est une marque d\u00e9pos\u00e9e) passe des contrats avec des constructeurs, des soci\u00e9t\u00e9s de d\u00e9veloppement, qui adaptent AT T UNIX, en y int\u00e9grant souvent tout ou partie des utilitaires d\u00e9velopp\u00e9s par l'universit\u00e9 de BEKELEY, aux caract\u00e9ristiques des mat\u00e9riels. Les versions ainsi adapt\u00e9es doivent obligatoirement avoir un nom commercial diff\u00e9rent d'UNIX, d'ou les nombreuses appellations. En voici une liste non exhaustive: XENIX de MICROSOFT (1) VENIX de VENTURE COM's (1) ZEUS de ZILOG (1) UNIPLUS de UNISOFT SYSTEMS (1) IDRIS de WHITE SMITHS (2) SOL de ADI INRIA ET SYSECA (2) INITY de DIGITAL EQUIPEMENT CORPORATION (3) IS/WB de INTERACTIVE SYSTEMS (3) (1) Authentique versions issues de BELL et comportant des variantes adapt\u00e9es en g\u00e9n\u00e9ral, pour tenir compte des diff\u00e9rences de mat\u00e9riels. (2) Syst\u00e8mes d'exploitation, de type UNIX, enti\u00e8rement r\u00e9\u00e9crits et offrant des possibilit\u00e9s identiques ou tr\u00e8s proches de celles d'UNIX. (3) Syst\u00e8mes d'exploitation, de type UNIX, fonctionnant sous le contr\u00f4le du syst\u00e8me d'exploitation de l'ordinateur h\u00f4te, offrant un environnement quasi-identique \u00e0 celui de AT T UNIX. Description g\u00e9n\u00e9rale UNIX est un syst\u00e8me d'exploitation multi-t\u00e2che, multi- utilisateur fonctionnant en temps partag\u00e9. Les programmes dont il assure le contr\u00f4le peuvent \u00eatre lanc\u00e9s en mode interactif ou en traitement batch. L'une des caract\u00e9ristiques principales d'UNIX par rapport au syst\u00e8me d'exploitation traditionnel est la gestion de tout p\u00e9riph\u00e9rique d'entr\u00e9e-sorties sous la forme d'un fichier. La gestion de l'ensemble de ces fichiers repr\u00e9sente un syst\u00e8me de gestion de fichiers hi\u00e9rarchis\u00e9s sous la forme d'un arbre. Cette possibilit\u00e9 permet ainsi de rediriger tous les r\u00e9sultats issus d'un programme comme param\u00e8tre d'entr\u00e9e d'un autre programme. De plus UNIX est fourni avec un ensemble d'utilitaires de base ainsi que d'une documentation en ligne. UNIX est aussi un syst\u00e8me de d\u00e9veloppement, donnant aux utilisateurs tous les outils permettant d'\u00e9crire, de mettre au point et de documenter leurs programmes. Le syst\u00e8me UNIX est compos\u00e9 : d'un noyau assurant la gestion de la m\u00e9moire et des entr\u00e9es sorties de bas niveau ainsi que de l'encha\u00eenement des diff\u00e9rentes t\u00e2ches . d'un (ou plusieurs suivant les versions) interpr\u00e9teur de commandes. d'un syst\u00e8me de messageries assez complet (courrier, conversation en temps r\u00e9el ) d'un grand nombre d'utilitaires, dont un compilateur de langage C, un g\u00e9n\u00e9rateur d'analyseur syntaxique lex, un g\u00e9n\u00e9rateur d'analyseur s\u00e9mantique yakk, etc ... Principales caract\u00e9ristiques du syst\u00e8me UNIX Ses principales caract\u00e9ristiques sont : Son syst\u00e8me de fichiers hi\u00e9rarchis\u00e9s (voir Chap 3) L'aspect multi-t\u00e2ches pour chaque utilisateur. La possibilit\u00e9s d'\u00e9crire des applications faisant directement appel au noyau par l'interm\u00e9diaire du langage C. Ses langages de commandes qui sont de v\u00e9ritables langages de programmation interpr\u00e9t\u00e9s, permettant l'\u00e9criture de programmes complexes. Son m\u00e9canisme de re-directions des entr\u00e9es sorties. En effet tout processus prend normalement ses donn\u00e9es depuis le clavier du terminal par lequel il a \u00e9t\u00e9 lanc\u00e9, de m\u00eame que ses sorties se font normalement sur l'\u00e9cran, il est possible d'associer aux entr\u00e9es sorties des fichiers quelconques ( UNIX consid\u00e9rant toutes les entr\u00e9es-sorties comme des fichiers sur lesquels il peut lire ou \u00e9crire ). UNIX allant plus loin puisque les sorties d'un programme peuvent \u00eatre consid\u00e9r\u00e9s comme les entr\u00e9es d'un autre programme.(communication entre processus par l'interm\u00e9diaire de tube, \"pipe\" en anglais). Portabilit\u00e9 Un certain nombre de constructeurs ont port\u00e9 UNIX sur leurs mat\u00e9riels : Digital, Bull, Hewlett Packard, Thompson, Cray, Apple..., ceci dans une gamme variant du micro-ordinateur au plus gros syst\u00e8me. L'une des facilit\u00e9s de la portabilit\u00e9 d'UNIX est le fait que 95% environ du syst\u00e8me est \u00e9crit dans un langage de haut niveau : Le langage C, les 5% restant \u00e9tant \u00e9crit en assembleur, ceci pour g\u00e9rer les drivers d'entr\u00e9e-sortie dans les couches les plus basses. Avec l'arriv\u00e9e de \"SYSTEM V\", l'utilisateur a pu modifier certains param\u00e8tres syst\u00e8me auxquels il n'avait pas acc\u00e8s sous \"System III\". Les logiciels serveur sont donc portables sur toutes les machines impl\u00e9ment\u00e9es avec le syst\u00e8me d'exploitation UNIX system V. Premier contact avec UNIX Session utilisateur Une session utilisateur commence par un \"login\" (entr\u00e9e dans le syst\u00e8me) et se termine par un \"login off\" (sortie du syst\u00e8me), entre les deux on peut ex\u00e9cuter des commandes, obtenir des r\u00e9ponses de la part de l'ordinateur. Une commande \u00e9tant le seul moyen d'effectuer quelque chose sur l'ordinateur. Une commande est un programme que l'on utilise pour faire une t\u00e2che d\u00e9sir\u00e9e. La commande est ex\u00e9cut\u00e9e en entrant son nom au clavier suivi de cr . Proc\u00e9dure d'entr\u00e9e sous UNIX Pour d\u00e9marrer une session utilisateur il faut poss\u00e9der un \"login id\" (id pour identificateur) et \u00e9ventuellement un mot de passe. Au message \"login:\" envoy\u00e9 par le syst\u00e8me, l'utilisateur doit saisir son \"login-id\". Ensuite au message \"password:\" il doit saisir son mot de passe. Si le nom et le mot de passe sont corrects l'utilisateur peut alors d\u00e9marrer sa session de travail sur la machine. Il est recommand\u00e9 d'entrer son \"login-id\" en minuscules, sinon UNIX (qui fait la diff\u00e9rence entre majuscules et minuscules) consid\u00e9rera que votre console ne reconna\u00eet pas les minuscules et vous affichera tout en majuscules. Exemple : login :daniel lt ; cr gt ; password : xxxxxxxxxx le mot de passe n est pas affich\u00e9 \u00e0 l \u00e9cran pour des raisons \u00e9videntes de s\u00e9curit\u00e9. Bienvenue sous 3B15 == Message de bienvenue. $ A l'entr\u00e9e sur le syst\u00e8me on obtient un prompt (par d\u00e9faut le caract\u00e8re \"\\$\") indiquant que UNIX est pr\u00eat \u00e0 acc\u00e9der \u00e0 tous vos d\u00e9sirs (ou presque). Un certain nombre de noms d'utilisateurs sont requis par le syst\u00e8me pour g\u00e9rer des taches particuli\u00e8res. Ces taches sont avant tout des taches syst\u00e8mes et administratives, ex : root est le super-utilisateur du syst\u00e8me, il a tous les droits (d'o\u00f9 la n\u00e9cessit\u00e9 de prot\u00e9ger son utilisation par l'interm\u00e9diaire d'un mot de passe). Manipulations des commandes UNIX Pour ex\u00e9cuter une commande sous UNIX, il suffit d'entrer son nom (Premier mot de la ligne entr\u00e9e) ainsi que des options dont elle a \u00e9ventuellement besoin. Format d'une ligne de commande : cmd [arg ...] cr cmd est le nom de la commande. arg repr\u00e9sente les param\u00e8tres optionnels de la commande. Chaque param\u00e8tre \u00e9tant s\u00e9par\u00e9 par un espace. Exemple avec la commande 'date La commande date permet d'afficher la date et l'heure du syst\u00e8me sur lequel vous \u00eates connect\u00e9s. Il y a une option pour date permettant de changer la date du syst\u00e8me mais elle n'est accessible que pour le super-utilisateur. $ date Mon Jan 11 14 :55:15 GMT 1988 $ Proc\u00e9dure d'arr\u00eat d'une commande Il est possible d'arr\u00eater le d\u00e9roulement d'une commande avant son terme. Par d\u00e9faut il s'agit de la combinaison de touches \"Ctrl-C\" la touche Control avec la touche C . L'utilisateur a la possibilit\u00e9 de changer cette touche. Proc\u00e9dure de sortie d'UNIX Pour terminer une session de travail il suffit d'envoyer le caract\u00e8re fin de fichier qui est par d\u00e9faut le caract\u00e8re \" \". Une autre possibilit\u00e9 est d'entrer la commande exit. Exemple : login :daniel password : xxxxxxxxx Bienvenue sous 3B15 $ date Mon Jan 11 14 :55:15 GMT 1988 Ctrl-d login : Premi\u00e8res Commandes. La commande \"banner\" Imprime ses arguments en gros caract\u00e8res. Elle est utilis\u00e9e pour l'\u00e9tiquetage, ou le titrage en sortie. $ banner Hello # # # # ###### # # #### # # # # # # # ####### ##### # # # # # # # # # # # # # # # # # # # # ###### ###### ###### #### $ La commande \"logname\" La commande logname vous donne votre nom d'utilisateur. La commande \"who\" La commande who permet de savoir qui est connect\u00e9 sur le syst\u00e8me. Avec les options \" am i \" ou \" am I \" permet de savoir qui on est. $ who am i daniel tty Tue 17 :44 La commande \"passwd\" Permet de changer son mot de passe. Entrer la commande passwd , elle vous demandera votre nouveau mot de passe et de le confirmer; si tout se passe bien votre nouveau mot de passe sera valide pour votre prochaine session. La commande \"echo\" Ecrit ses arguments et passe a la ligne suivante. Passe \u00e0 la ligne si elle n'a aucun argument. La commande reconna\u00eet quelques caract\u00e8res sp\u00e9ciaux: caract\u00e8res description \\b backspace : retour arri\u00e8re \\c Affiche la ligne sans passer \u00e0 la ligne \\f form feed : efface l'\u00e9cran \\n New line: passe \u00e0 la ligne \\t tabulation \\v tabulation verticale \\ le caract\u00e8re Sur les versions de linux il faut activer les caract\u00e8res sp\u00e9ciaux via l'option -e . La commande \"man\" Si l'on n'a pas le manuel sous la main. man permet de savoir ce que fait tel ou tel commande, ainsi que les options de la commande. l'option \"-k\" suivi de mots cl\u00e9s affiche un r\u00e9sum\u00e9 des commandes pass\u00e9es en arguments. Pour savoir comment marche la commande man entrer : $ man man Le shell Le shell est l'interpr\u00e9teur de commandes. Il existe plusiseurs interpr\u00e9teur de commandes : sh , ksh , csh , bash , bash \u00e9tant le plus r\u00e9pandu de nos jours. Il interpr\u00e8te ce que vous tapez au clavier pour l'ex\u00e9cuter. Lorsque vous tapez un retour-chariot il interpr\u00e8te le texte que vous avez \u00e9crit et ex\u00e9cute la commande dont le nom est le premier mot de la ligne. C'est lui qui vous affiche le prompt (par d\u00e9faut \"\\$\") vous invitant \u00e0 taper quelque chose. Le syst\u00e8me de fichiers Qu'est ce qu'un fichier Un fichier est un lieu de stockage d'informations, c'est un nom et des donn\u00e9es associ\u00e9es. Par exemple la commande date est un nom et un fichier programme associ\u00e9. Un terminal est un fichier sur lequel on peut \u00e9crire : l'\u00e9cran, et sur lequel on peut lire : le clavier. UNIX consid\u00e8re toutes les entr\u00e9es/sorties comme des fichiers, donc: les programmes, les p\u00e9riph\u00e9riques, les donn\u00e9es sont tous consid\u00e9r\u00e9s comme des fichiers. Sous unix un fichier peut avoir plusieurs noms (Voir la commande ln ). Pr\u00e9sentation g\u00e9n\u00e9rale Un fichier sous unix est une cha\u00eene de caract\u00e8res non structur\u00e9e du point de vue du syst\u00e8me. UNIX ne poss\u00e8de aucune notion d'organisation de fichiers telle que les fichiers s\u00e9quentiels, index\u00e9s, partitionn\u00e9s. A tout fichier est associ\u00e9 un bloc d'information : le i-node contenant un certain nombre d'informations sur celui-ci : sa taille. l'adresse des blocs sur le disque o\u00f9 les donn\u00e9es sont r\u00e9ellement \u00e9crites. l'identification du propri\u00e9taire. Un compteur de r\u00e9f\u00e9rence dans le syst\u00e8me. un certains nombre de dates relatives au fichier. On remarquera que ce bloc ne contient aucun nom d'identification pour le fichier. Les noms sont gard\u00e9s dans des fichiers sp\u00e9cifiques : Les catalogues (ou r\u00e9pertoires ou encore directories). Sous UNIX il existe trois types de fichiers : Les fichiers ordinaires ( type data, texte, ou binaire). Les fichiers directory (r\u00e9pertoire ou catalogue en fran\u00e7ais). Les fichiers sp\u00e9ciaux. Il s'agit des fichiers drivers (exemple le disque, le terminal). Il existe deux types de fichiers sp\u00e9ciaux : Les fichiers sp\u00e9ciaux de type caract\u00e8res (Le terminal) Les fichiers sp\u00e9ciaux de type blocs (Le disque) Un fichier est r\u00e9f\u00e9renc\u00e9 par un nom dans une directory. Un m\u00eame fichier peut \u00eatre r\u00e9f\u00e9renc\u00e9 plusieurs fois dans diff\u00e9rents catalogues. Le catalogue \u00e9tant lui m\u00eame r\u00e9f\u00e9renc\u00e9 dans un autre catalogue. Cette architecture n\u00e9cessite l'existence d'un r\u00e9pertoire sp\u00e9cial dont le syst\u00e8me conna\u00eet l'emplacement, il s'agit du r\u00e9pertoire racine not\u00e9 \" / \". La structure des fichiers sous UNIX est donc une arborescence, on trouvera sous celui-ci des r\u00e9pertoires commun \u00e0 tous les syst\u00e8mes UNIX. R\u00e9f\u00e9rence des fichiers et r\u00e9pertoire de travail Architecture de l'arborescence des fichiers sous UNIX. / / usr / bin / etc / dev / tty1 / home / daniel Le syst\u00e8me de fichiers forme une arborescence, les noeuds sont des catalogues et les feuilles des fichiers ou des catalogues vides. Nous pouvons nous d\u00e9placer dans cette arborescence au moyen de certaines commandes. Le nom d'un fichier peut \u00eatre donn\u00e9 soit par sa r\u00e9f\u00e9rence absolue c'est \u00e0 dire son nom complet depuis la racine, soit par sa r\u00e9f\u00e9rence relative c'est \u00e0 dire par rapport au r\u00e9pertoire sur lequel on se trouve. Par convention une r\u00e9f\u00e9rence relative est une r\u00e9f\u00e9rence ne commen\u00e7ant pas par le caract\u00e8re \" / \". Le rep\u00e9rage des fichiers est facilit\u00e9 par l'existence dans toutes les directories de deux r\u00e9f\u00e9rences particulieres qui sont : . et .. point et point point, ils d\u00e9signent respectivement le r\u00e9pertoire courant et le r\u00e9pertoire au dessus ou pr\u00e9c\u00e9dent avec une exception pour le r\u00e9pertoire racine qui d\u00e9signe alors lui m\u00eame. Exemple , si nous sommes dans le r\u00e9pertoire /home/daniel r\u00e9f\u00e9rence designation /home/daniel/toto.c R\u00e9f\u00e9rence absolue au fichier toto.c se trouvant dans le r\u00e9pertoire /home/daniel ../daniel/toto.c R\u00e9f\u00e9rence relative par rapport au r\u00e9pertoire courant (on remonte d'un cran et on redescend) toto.c R\u00e9f\u00e9rence relative par rapport au r\u00e9pertoire courant . d\u00e9signe /home/daniel .. d\u00e9signe le r\u00e9pertoire parent : /home Tous les fichiers commen\u00e7ant par le caract\u00e8re . n'apparaissent pas avec les commandes normales d'affichage des fichiers, ils sont consid\u00e9r\u00e9s comme des fichiers cach\u00e9s. Tous les utilisateurs poss\u00e9dent leur propre r\u00e9pertoire de travail qui est par d\u00e9faut le repertoire courant au moment du \"login\". Il existe quelques r\u00e9pertoires communs \u00e0 tous les syst\u00e8mes UNIX. r\u00e9pertoire description / La racine du syst\u00e8me /usr Contient ce qui est utilis\u00e9 par l'utilisateur : compilateurs, librairies, etc. /bin et /usr/bin Contient les programmes associ\u00e9s aux commandes UNIX /dev contient les fichiers sp\u00e9ciaux /etc contient les fichiers syst\u00e8mes /tmp tous les fichiers temporaires La protection des fichiers Sous UNIX tout utilisateur poss\u00e8de, associ\u00e9 \u00e0 son identification un num\u00e9ro de compte et appartient \u00e0 un groupe d'utilisateur. Ainsi pour un fichier donn\u00e9 les utilisateurs peuvent \u00eatre class\u00e9s en trois cat\u00e9gories : Le propri\u00e9taire du fichier (Celui qui l'a cr\u00e9\u00e9). Les membres du groupe du propri\u00e9taire. tous les autres. Sans oublier le super-utilisateur root, qui lui, a tous les droits. Trois contr\u00f4les \u00e9l\u00e9mentaires sont faits par le syst\u00e8me: Les droits de lecture (repr\u00e9sent\u00e9 par r pour r ead) Les droits d'\u00e9criture ( repr\u00e9sent\u00e9 par w pour w rite) Les droits d'ex\u00e9cution(repr\u00e9sent\u00e9 par x pour e x ecution Pour un r\u00e9pertoire : Le droit d'ex\u00e9cution signifie la possibilit\u00e9 pour un utilisateur de se positionner sur ce r\u00e9pertoire (en fait plut\u00f4t de le traverser). Le droit de lecture \u00e9tant de lire le contenu du r\u00e9pertoire. Le droit d'\u00e9criture donne la possibilit\u00e9 de cr\u00e9er des fichiers dans celui-ci ainsi que d'effacer des fichiers dans ce r\u00e9pertoire m\u00eame si l'on n'a pas les droits d'\u00e9criture sur ces fichiers. Il existe aussi trois autres bits de contr\u00f4les sur les fichiers qui ont un r\u00f4le sp\u00e9cial: le set-uid : Lorsqu'il est positionn\u00e9 donne \u00e0 l'utilisateur du programme les droits du cr\u00e9ateur du programme et non ceux de l'utilisateur du programme. le set-guid : Idem \u00e0 set-uid mais au niveau du groupe. le sticky-bit : qui permet au contr\u00f4leur de processus de garder ce programme en m\u00e9moire (RAM) m\u00eame si d'autres en ont besoin. Les commandes de manipulations de fichiers. Nous allons voir ici les principales commandes permettant de manipuler les fichiers et les r\u00e9pertoires. La commande \"pwd\" Affiche le nom du repertoire courant \u00e0 partir de la racine. $ pwd /home/daniel $ La commande \"cd\" Permet de changer de r\u00e9pertoire de travail courant. Sans param\u00e9tre permet de revenir au r\u00e9pertoire par d\u00e9faut du login (attention, celui-ci peut \u00eatre chang\u00e9). Exemple: $ pwd /home/daniel $ cd /usr/bin # Positionnement absolu $ pwd /usr/bin $ cd ../include # Positionnement relatif $ pwd /usr/include $ cd # Sans param\u00e8tre retour au pwd : HOME directory /u1/daniel $ La commande \"ls\" Format : ls [-options] [arg] Permet d'afficher la liste des fichiers dans le r\u00e9pertoire courant ou le r\u00e9pertoire pass\u00e9 en argument. quelques options: -l affiche en format long (donne plus d'informations) donnant: le mode du fichier et le type. le nombre de liens.(nombre de r\u00e9f\u00e9rences du fichier) le propri\u00e9taire. le groupe du propri\u00e9taire. la taille (en octets) la date de derni\u00e8re modification. le nom -o identique \u00e0 -l mais sans le groupe. -g identique \u00e0 -l mais sans le propri\u00e9taire. -t impression avec tri dans l'ordre des modifications (derni\u00e8res en t\u00eate) -a tout les noms des fichiers sont imprim\u00e9s alors que par d\u00e9faut les fichiers commen\u00e7ant par le caract\u00e8re \".\" ne sont pas affich\u00e9s. -d si l'argument est un r\u00e9pertoire seul son nom est affich\u00e9. -r l'ordre d'impression est invers\u00e9 (quelque soit le tri ) -u le tri est fait selon les dates de consultation. -i pour chaque fichier affiche son num\u00e9ro d'i-node Avec l'option -l la commande ls affiche les protections appliqu\u00e9es aux entr\u00e9es (r\u00e9pertoire, fichiers, fichiers sp\u00e9ciaux) dans l'ordre suivant: type de fichier (un caract\u00e8re) un groupe de 3 caract\u00e8re pour le propri\u00e9taire un groupe de 3 caract\u00e8res pour le groupe un groupe de 3 caract\u00e8res pour le reste du monde les protections sont positionn\u00e9es de la mani\u00e8re et dans l'ordre suivant, ceci pour chaque type d'utilisateur : r autorise la lecture- sinon w autorise l'\u00e9criture- sinon x autorise l'ex\u00e9cution - sinon type de fichiers fichier normal d fichier directory l lien symbolique c fichier sp\u00e9cial de type caract\u00e8res b fichier sp\u00e9cial de type blocs p sur UNIX system III et V indique les tubes nomm\u00e9s Si le set-uid est positionn\u00e9 le caract\u00e8re \" s \" sera \u00e9crit au lieu de \" x \" dans les droits d'ex\u00e9cution du propri\u00e9taire. Si le set-guid est positionn\u00e9 le caract\u00e8re \" s \" sera \u00e9crit au lieu de \" x \" dans les droits d'ex\u00e9cution du groupe. Si le sticky-bit est positionn\u00e9 le caract\u00e8re \" t \" sera \u00e9crit au lieu de \" x \" dans les droits d'ex\u00e9cution des autres. La commande \"cat\" Format : cat \\[arg ...\\] Permet d'afficher \u00e0 l'\u00e9cran le contenu des fichiers pass\u00e9s en arguments. La commande \"cp\" Format : cp fichier-source fichier-dest Permet de dupliquer des fichiers. \"cp\" effectue la copie physique du premier argument dans le second. Il y a cr\u00e9ation d'un nouvel i-node et recopie effective des donn\u00e9es. Exemple : $ pwd # affiche le r\u00e9pertoire courant /home/daniel $ ls # pas de fichier dans le repertoire $ cat toto un contenu dans le fichier Ctrl-d # appui sur la touche Control et sur la touche D $ ls toto $ cp toto tutu $ ls toto tutu $ La commande \"ln\" Format : ln fichier-source fichier-dest Permet de cr\u00e9er des liens. Nous avons vu qu'un m\u00eame fichier peut avoir plusieurs noms mais correspondre au m\u00eame bloc de donn\u00e9es sur le disque. Il n'y a pas cr\u00e9ation d'un nouvel i-node. il n'y a pas de de duplication des donn\u00e9es. Exemple: $ ls -il 8122435 -rw------- 1 daniel daniel 27 Janv 13 18 :04 toto $ cp toto tata $ ls -il 8122489 -rw------- 1 daniel daniel 27 Janv 13 18 :14 tata 8122435 -rw------- 1 daniel daniel 27 Janv 13 18 :04 toto $ ln tata tatalinked $ ls -il 8122489 -rw------- 2 daniel daniel 27 Janv 13 18 :14 tata 8122489 -rw------- 2 daniel daniel 27 Janv 13 18 :14 tatalinked 8122435 -rw------- 1 daniel daniel 27 Janv 13 18 :04 toto $ # le fichier tatalinked est une r\u00e9f\u00e9rence au fichier tata, $ # il n y a pas duplication de donn\u00e9es $ La commande \"mv\" Format : mv fichier-source fichier-destination Change le nom d'un lien. il n'y a pas recopie physique mais uniquement modification du nom. La commande \"rm\" Format : rm [-options] arg [arg...] Efface les fichiers sp\u00e9cifi\u00e9s par les arguments pass\u00e9s en param\u00e9tre. Les options : -i affiche chaque nom des fichiers demand\u00e9s et demande la confirmation de la suppression (appui sur \"y\" pour oui) -r provoque la suppression de tous les fichiers dans toutes les directories et sous directories sp\u00e9cifi\u00e9es de mani\u00e8re recursive ( attention tr\u00e9s dangereux, \u00e0 manier avec pr\u00e9cautions !) On ne peut pas effacer un r\u00e9pertoire avec la commande \"rm\" sans l'option -r . La commande \"mkdir\" Format : mkdir arg [arg...] Permet de cr\u00e9er des r\u00e9pertoires. La commande \"rmdir\" Format : rmdir arg [arg...] Permet de supprimer des r\u00e9pertoires. Les r\u00e9pertoires ne seront supprim\u00e9s que si ils sont vides. $ pwd /home/daniel $ ls -d $ mkdir dir1 dir2 $ ls toto tata dir1 dir2 $ mv tata dir1 $ ls toto dir1 dir2 $ls dir1 tata $ rmdir dir2 dir1 dir1 : directory not empty $ rm dir1/* $ rmdir dir1 $ ls toto $ Modification des caract\u00e9ristiques d'un i-node Le propri\u00e9taire d'un fichier peut modifier le nom du propri\u00e9taire, du groupe, et des droits d'acc\u00e9s des diff\u00e9rents utilisateurs de ce fichier et lui seul (Avec le super-utilisateur). Les commandes sont : chmod, chown, chgrp. La commande \"chgrp\" Format : chgrp group file [file...] Change le groupe pour les fichiers sp\u00e9cifi\u00e9s. le groupe peut \u00eatre donn\u00e9 par son num\u00e9ro ou par son nom. La commande \"chown\" Format : chown nom file [file...] Change le propi\u00e9taire des fichiers sp\u00e9cifi\u00e9s.le nom peut \u00eatre donn\u00e9 par son num\u00e9ro ou par son nom lit\u00e9ral. La commande \"chmod\" Format : chmod mod file [file...] Permet de modifier les bits de protection des fichiers. Les modes peuvent \u00eatre d\u00e9crits en octal ou en symbolique. format de mode en symbolique: [ qui ] perm op qui u propri\u00e9taire (user) g groupe o autres (other) a pour tous (all) perm + rajoute la permision - enleve la permission = impose les permission (absolu) op r lecture w \u00e9criture x ex\u00e9cution t pour le \"sticky-bit\" s pour le \"set-uid\" bit (associ\u00e9 \u00e0 u) ou le \"set-guid\" (associ\u00e9 \u00e0 g) Les entr\u00e9es-sorties, M\u00e9canismes de redirection Certaines commandes ne produisent pas de sortie, comme la commande cp sauf s'il y a une erreur, d'autres font uniquement des sorties sur l'\u00e9cran du terminal telles que date , who , ls ... Certaines font des lectures en entr\u00e9e. En fait tout programme sous UNIX connait TROIS types de fichiers qui sont : stdin : Fichier standard d'entr\u00e9e (par d\u00e9faut le clavier du terminal) stdout : Fichier standard de sortie (par d\u00e9faut l'\u00e9cran du terminal) stderr : Fichier standard d'affichage des erreurs (Par d\u00e9faut l'\u00e9cran du terminal) Les entr\u00e9es sorties \u00e9tant des fichiers il est possible de les rediriger vers d'autres fichiers ( fichiers data, fichiers devices ) de telle sorte qu'au lieu d'utiliser le terminal les programmes peuvent aller lire ou \u00e9crire leurs donn\u00e9es sur des fichiers. La redirection des entr\u00e9es sorties est g\u00e9r\u00e9e par le shell. Les commandes de redirection, file d\u00e9signant le nom d'un fichier : symbole entr\u00e9e/sortie description file stdout redirige vers le fichier sp\u00e9cifi\u00e9, si ce dernier existe il est tronqu\u00e9 \u00e0 z\u00e9ro caract\u00e8re sinon il est cr\u00e9\u00e9e. file stdout Idem sauf si le fichier existe les donn\u00e9es sont rajout\u00e9es en fin de celui-ci. 2 file stderr Idem \u00e0 pour la sortie d'erreur 2 file stderr Idem \u00e0 pour la sortie d'erreur file stdin les donn\u00e9es sont lues depuis le fichier sp\u00e9cifi\u00e9 TOTO stdin lit depuis l'entr\u00e9e standard courante jusqu'\u00e0 trouver la cha\u00eene TOTO, TOTO pouvant \u00eatre remplac\u00e9 par les caract\u00e8res de votre choix. cmd1 | cmd2 stdout vers stdin Permet d'enchainer 2 commandes, la sortie standard de la commande cmd1 devenant l'entr\u00e9e standard de cmd2 La commande \"wc\" Format : wc [option] Permet suivant l'option de compter le nombre de mots,de lignes, de caract\u00e9res lus au clavier jusqu'\u00e0 rencontrer le caract\u00e8re de fin de fichier Ctrl-d . Les options : -l compte le nombres de lignes. -w compte le nombre de mots -c compte le nombre de caract\u00e9res. sans option c'est -lwc qui est pris. Exemple: $ ls toto $ date fich1 $ ls toto fich1 $ cat fich1 Mon Jan 11 17 :38 GMT 1988 wc -l fich1 1 $ Fichiers et processus G\u00e9n\u00e9ralit\u00e9s et pr\u00e9sentation Un processus est l'ex\u00e9cution d'un programme \u00e0 un instant donn\u00e9, le fichier programme \u00e9tant un objet inerte rang\u00e9 sur disque. On peut distinguer deux types de processus : Les processus syst\u00e8mes qui ne sont attach\u00e9s \u00e0 aucun type de terminal, qui sont cr\u00e9\u00e9s au lancement du syst\u00e8me ou \u00e0 des dates fixes. Les premiers ne s'arr\u00eatant qu'avec l'arr\u00eat du syst\u00e8me. Les processus lanc\u00e9s par un utilisateur particulier depuis un terminal donn\u00e9. Le fait de se 'loguer' cr\u00e9e un processus correspondant \u00e0 l'ex\u00e9cution d'un programme d\u00e9termin\u00e9 \u00e0 l'avance pour chaque utilisateur. La plupart du temps il s'agit de l'ex\u00e9cution de l'interpr\u00e9teur de commande : le shell. Un point fondamental pour un processus est l'environnement. Chaque processus a un environnement dont il h\u00e9rite du processus qui l'a lanc\u00e9 : le processus p\u00e8re. Par exemple vous lancez la commande \"rm\", votre shell g\u00e9n\u00e8re un nouveau processus qui sera cr\u00e9\u00e9 pour ex\u00e9cuter le programme qui effectue la tache d'effacement de fichiers. Ce nouveau processus h\u00e9rite de l'environnement de votre shell en particulier du r\u00e9pertoire courant o\u00f9 vous vous trouvez au moment du lancement de la commande. Chaque processus est identifi\u00e9 par son \"process-id\" (PID) le num\u00e9ro du processus p\u00e8re \u00e9tant identifi\u00e9 par le PPID. La diff\u00e9rence entre le processus p\u00e8re et le fils est que l'\u00e2ge a effet sur sa priorit\u00e9; en particulier la destruction du processus p\u00e8re entra\u00eene la destruction de tous ses processus fils (par d\u00e9faut). La commande \"ps\" Format : ps [options] Permet d'avoir la liste des processus en cours dans le syst\u00e8me. \" ps \" sans argument donne la liste des processus attach\u00e9s \u00e0 votre terminal. Quelques options: -e informations sur tous les processus en cours sur la machine. -a information sur les processus associ\u00e9s aux terminaux. -f liste toutes les informations sur les processus. -l liste longue des informations. -t suivi d'une liste de num\u00e9ro donne la liste des processus associ\u00e9s \u00e0 ces terminaux. Ex: ps -t tty05,tty10 donne la liste des processus attach\u00e9s aux terminaux tty05 et tty10. D\u00e9tails sur les informations fournies par ps. PID num\u00e9ro du processus. PPID num\u00e9ro du processus p\u00e8re. TTY Terminal auquel est rattach\u00e9 le processus. TIME Dur\u00e9e cumul\u00e9e d'ex\u00e9cution. COMMAND Commande qui a \u00e9t\u00e9 ex\u00e9cut\u00e9e. UID num\u00e9ro du propri\u00e9taire du processus. CT aux d'utilisation de la CPU (Utilis\u00e9 pour le calcul de la priorit\u00e9 du processus). PRI Priorit\u00e9 du processus, les chiffres les plus hauts correspondants aux priorit\u00e9s les plus faibles. STIME Heure de lancement du processus. Le Shell Le shell est un processus important, tout utilisateur qui se connecte a sa copie du programme \"sh\" qui s'ex\u00e9cute dans son environnement. On peut Empiler plusieurs shells pour travailler sous diff\u00e9rents environnements. Si l'on tape \"sh\" on lance un nouveau processus. Exemple : login: daniel password: Bienvenue sous UNIX $ ps PID TTY TIMECOMMAND 745 4500 :06 sh 850 4500 :01 ps $ sh $ ps PID TTY TIMECOMMAND 745 4500 :08 sh 860 4500 :06 sh 865 4500 :01 ps $ On a deux shells qui s'ex\u00e9cutent en m\u00eame temps. Si l'on se d\u00e9logue en entrant Ctrl-d on obtient : $ Ctrl-d $ ps PID TTY TIMECOMMAND 745 4501 :10 sh 956 4500 :01 ps $ Ctrl-d login: Autre exemple : Environnement d'un processus. $ pwd /home/daniel $ sh $ pwd /home/daniel # On h\u00e9rite de l environnement du p\u00e8re. $ cd /usr/include $ pwd /usr/include $ Ctrl-d ; $ pwd /home/daniel # Mais pas l inverse : l environnement du fils n est pas transmis au p\u00e8re. $ Lancement d'un processus en arri\u00e8re plan Le shell qui cr\u00e9e un processus en arri\u00e8re plan reprend la main sans attendre que celui-ci soit termin\u00e9. $ps PID TTY TIMECOMMAND 745 4500 :06 sh 850 4500 :01 ps $ ls -al fich1 800 $ ps -edf PID TTY TIMECOMMAND 745 4500 :06 sh 800 4500 :01 ls -al fich1 850 4500 :01 ps $ C'est le caract\u00e8re \" \" qui permet de lancer des processus en arri\u00e8re plan. Quand un processus est lanc\u00e9 en arri\u00e8re plan le shell renvoie le num\u00e9ro de process qui lui a \u00e9t\u00e9 attribu\u00e9. Attention un processus lanc\u00e9 en arri\u00e8re-plan (background) est quand m\u00eame d\u00e9truit en cas de d\u00e9connexion car il reste attach\u00e9 au terminal d'o\u00f9 il a \u00e9t\u00e9 lanc\u00e9. De plus un processus en arri\u00e8re plan a les m\u00eames entr\u00e9es-sorties que le processus p\u00e8re, il est donc conseill\u00e9 de rediriger les sorties, sinon les messages appara\u00eetront au fur et \u00e0 mesure sur le terminal. La Commande \"nohup\" Format : nohup commande [args] La commande \" nohup \" permet de d\u00e9tacher un processus du terminal.On pourra donc lancer de longs travaux sans monopoliser le terminal puisque les processus lanc\u00e9s par l'interm\u00e9diaire de la commande \"nohup\" seront d\u00e9tach\u00e9s du terminal, on pourra se d\u00e9connecter, nos processus continuerons \u00e0 tourner. Si l'on ne redirige pas les sorties la commande les redirigera vers un fichier nomm\u00e9 \"nohup.out\". $ nohup ps -efl fich1 850 $ ps PID TTY TIMECOMMAND 745 4500 :06 sh 850 4500 :01 nohup ps -efl fich1 980 4500 :01 ps $ La commande \"wait\" La commande wait attend la fin des processus lanc\u00e9s en arri\u00e8re plan. La commande \"nice\" Format : nice [-increment] commande [args...] Permet de changer artificiellement la priorit\u00e9 d'un processus. On ne peut pas augmenter sa priorit\u00e9, mais seulement la baisser (sauf le super-utilisateur). Cela permet d'effectuer des travaux non-urgents en arri\u00e8re-plan. La priorit\u00e9 par d\u00e9faut est 10. La valeur d'incr\u00e9ment est comprise entre 1 et 19 (plus faible). La commande \"at\" Format : at heure jour [ fichier ] Permet de lancer une commande en arri\u00e8re plan \u00e0 une date et une heure fix\u00e9es. La commande n'est pas attach\u00e9 \u00e0 un terminal (comme pour la commande \"nohup\". heure form\u00e9 de 1 \u00e0 4 chiffres peut \u00eatre suivi des lettres : a : am p : pm n : midi m : minuit jour est optionnel (par d\u00e9faut le jour courant) $ # Lance la commande ls -l fich \u00e0 18:00h le 15 janvier. $ at 18 jan 15 ls -l fich $ Destruction d'un processus Le fait de se d\u00e9connecter tue tous les processus attach\u00e9s au terminal. Autrement il faut utiliser la commande kill . Si l'on n'a plus la main sur son terminal pour une raison ou une autre on peut toujours se connecter par l'interm\u00e9diaire d'un autre terminal. La commande \"kill\" Format : kill [-num\u00e9ro] PID [PID...] Permet de tuer des processus. Le num\u00e9ro de signal est compris entre 1 et 15. Le signal n\u00b0 2 correspond \u00e0 INTR Le signel n\u00b0 3 correspond \u00e0 QUIT L'arme absolue contre les processus r\u00e9calcitrants est : kill -9 PID Ceci \u00e0 condition d'\u00eatre le propri\u00e9taire du processus ou d'\u00eatre le super-utilisateur. Editeur de texte vi Introduction \u00e0 vi Vi est un \u00e9diteur de texte pleine page. Il \u00e0 \u00e9t\u00e9 d\u00e9velopp\u00e9 \u00e0 l'Universit\u00e9 de Berkeley, mais est n\u00e9anmoins disponible sur la plupart des versions de UNIX. Ces principales caract\u00e9ristiques sont : Un syst\u00e8me de r\u00e9cup\u00e9ration et de sauvegarde sophistiqu\u00e9. Poss\u00e8de les m\u00eames possibilit\u00e9s que l'\u00e9diteur ligne ed. Poss\u00e8de un jeu de commandes puissant. Travaille sur une image m\u00e9moire du fichier \u00e9dit\u00e9. Vi \u00e9tant un \u00e9diteur pleine page, il utilise les attributs vid\u00e9o du terminal, qu'il conna\u00eet par l'interm\u00e9diaire de la variable TERM de l'environnement. L'initialisation de la variable se fait par : $ TERM = valeur $ export TERM $ Appel de l'\u00e9diteur. Il existe plusieurs fa\u00e7on d'appeler l'\u00e9diteur: vi nom : \u00e9dite le fichier et place le curseur sur la 1ere colonne de la 1ere ligne. vi +n nom : \u00e9dite le fichier et place le curseur sur la 1ere colonne de la ligne n. vi + nom : \u00e9dite le fichier et place le curseur sur la 1ere colonne de la derni\u00e8re ligne. vi +/ chaine / nom / : \u00e9dite le fichier et place le curseur sur le premier caract\u00e8re de la ligne contenant la premi\u00e8re occurrence de chaine Il est possible de cr\u00e9er un fichier qui sera ex\u00e9cut\u00e9 \u00e0 chaque appel de vi ce fichier doit avoir comme nom \".exrc\" dans le r\u00e9pertoire priv\u00e9 de l'utilisateur. Si ce fichier existe il sera consid\u00e9r\u00e9 comme un ensemble de commandes \u00e0 ex\u00e9cuter. Les commandes de vi L'\u00e9diteur poss\u00e8de deux modes de travail : le mode insertion : tout ce qui entr\u00e9 au clavier est \u00e9crit dans le tampon en m\u00e9moire associ\u00e9 au fichier. Le mode commande : dans lequel tout ce qui est entr\u00e9 au clavier est interpr\u00e9t\u00e9 comme une commande de l'\u00e9diteur. le mode commande \u00e9tendue (commandes commen\u00e7ant par ':') La touche Esc Permet de sortir du mode insertion et de passer en mode commande. Pour sortir de l'\u00e9diteur ZZ sort de l'\u00e9diteur et sauvegarde les modifications (deux fois la touche ) Commandes G\u00e9n\u00e9rales on commence toujours par appyer sur Esc , cela ne fait pas de mal et on est sur de sortir du mode insertion. commande description :f donne la r\u00e9f\u00e9rence du fichier en cours d'\u00e9dition. ZZ ou :wq Sort de l'\u00e9diteur et sauvegarde les modifications. :w Sauvegarde du fichier sous son nom d'entr\u00e9e. :w nom Sauvegarde le fichier sous le nom nom ,le nom du tampon courant n'est pas modifi\u00e9. :w! Force l'\u00e9criture (utile dans certains cas). :q Sortie de l'\u00e9diteur,possible uniquement s'il n'y a pas eu modification. :q! Force la sortie sans modification. :e nom \u00e9dite le fichier nom uniquement si l'ancien est sauvegard\u00e9. :e! nom force l'\u00e9dition du nouveau fichier. :w n1 , n2 nom \u00e9crit uniquement les lignes comprises entre n1 et n2. :r nom introduit le fichier nom en dessous de la ligne courante. :r! commande introduit le r\u00e9sultat de la commande shell commande apr\u00e8s la ligne courante. :! commande Ex\u00e9cute la commande du shell commande Ctrl-l Rafra\u00eechissement de l'\u00e9cran. Utile lorsque le r\u00e9sultat d'op\u00e9ration provoque des affichages parasites. :se nu Affiche les num\u00e9ros de ligne en d\u00e9but de chaque... ligne (:se nonu pour les enlever) \u200b D\u00e9placement du curseur Dans les commandes qui suivent n d\u00e9signe un facteur de r\u00e9p\u00e9tition il peut \u00eatre omis (de nos jours les fl\u00eaches fonctionnent tr\u00e8s bien). commande description n h d\u00e9place le curseur vers la gauche. n espace ou n l (L minuscule) d\u00e9place le n Ctrl-n ou n j d\u00e9place le curseur vers le bas. n Ctrl p ou n k d\u00e9place le curseur vers le haut. n + ou n cr descend le curseur de n lignes. n w d\u00e9place le curseur en d\u00e9but de mot suivant. n b d\u00e9place le curseur en d\u00e9but de mot pr\u00e9c\u00e9dent. n e d\u00e9place le curseur en fin de mot courant. n G d\u00e9place le curseur \u00e0 la ligne sp\u00e9cifi\u00e9. (par d\u00e9faut en fin de texte.) n Ctrl-u remonte de n lignes.(par d\u00e9faut \u00e0 une demi-page) n Ctrl-e descend de n lignes.(par d\u00e9faut \u00e0 une demi-page) Commandes de suppression de texte. Dans les commandes qui suivent n d\u00e9signe un facteur de r\u00e9p\u00e9tition il peut \u00eatre omis. commande description n x supprime le caract\u00e8re sous le curseur. n X supprime le caract\u00e8re pr\u00e9c\u00e9dent le curseur. D supprime la fin de la ligne. n d w supprime le mot. n d d supprime la ligne. Commandes de recherche (cha\u00eene de caract\u00e8res) commande description n f car recherche du premier car sur la fin de la ligne courante et se positionne dessus. n F car recherche du premier car sur le d\u00e9but de la ligne courante et se positionne dessus. n t car recherche du premier car sur la fin de la ligne courante et se positionne sur le caract\u00e8re pr\u00e9c\u00e8dent. n T car recherche du premier car sur le d\u00e9but de la ligne courante et se positionne sur le caract\u00e8re pr\u00e9c\u00e8dent. n ; r\u00e9p\u00e8te l'une des op\u00e9rations f , F , t ou T. n , r\u00e9p\u00e8te l'une des op\u00e9rations f , F , t ou T dans le sens oppos\u00e9. n / motif [/] cr Recherche la premi\u00e8re occurrence de motif n ? motif [?] cr idem mais dans le sens oppos\u00e9. n r\u00e9p\u00e9tition d'une op\u00e9ration /ou ? dans le sens courant N r\u00e9p\u00e9tition d'une op\u00e9ration ?ou / dans le sens oppos\u00e9 Commandes d'insertion Le caract\u00e8re Escape permet de repasser en mode commande. commande description a passe en mode entr\u00e9e apr\u00e8s le caract\u00e8re courant. i passe en mode entr\u00e9e avant le caract\u00e8re courant. A passe en mode entr\u00e9e en fin de ligne. I passe en mode entr\u00e9e en d\u00e9but de ligne. o passe en mode entr\u00e9e apr\u00e8s la ligne courante. O passe en mode entr\u00e9e avant la ligne courante. En mode insertion les caract\u00e8res suivant ont un r\u00f4le privil\u00e9gi\u00e9 commande description Escape passage en mode commande. Ctrl-h effacement du caract\u00e8re pr\u00e9c\u00e9dent. (m\u00eame si la visualisation n'est pas Ctrl-v Permet d'introduire dans le fichier tous les caract\u00e8res. Commandes de modification commande description n cw chaine Remplace le mot par chaine n cc chaine Remplace les n lignes par chaine n J joint la ligne courante et la suivante. n s chaine Substitue aux n caract\u00e8res la chaine chaine . R Substitution d'une chaine jusqu'\u00e0 Escape r Substitution du caract\u00e8re courant. Commandes de r\u00e9cup\u00e9ration Chaque op\u00e9ration de suppression ou de modification est stock\u00e9 dans un buffer sp\u00e9cial qu'il est possible de r\u00e9cup\u00e9rer. Il existe plus de 26 buffers num\u00e9rot\u00e9s de a \u00e0 z qu'il est possible d'utiliser. Ils sont not\u00e9s dans le tableau ci-dessous. commande description \" lettre n yw m\u00e9morise n mots dans le buffer lettre \" lettre n yy m\u00e9morise n lignes dans le buffer lettre \" lettre p ins\u00e8re le buffer lettre apr\u00e8s le curseur. \" lettre P ins\u00e8re le buffer lettre avant le curseur. p ins\u00e8re le buffer sp\u00e9cial apr\u00e8s le curseur. P ins\u00e8re le buffer sp\u00e9cial avant le curseur. u annulation de la commande pr\u00e9c\u00e9dente. Quelques commandes particuli\u00e8res commande description :se all cr Affiche l'\u00e9tat de l'\u00e9diteur. :se ai cr auto-indentation :se wm= valeur coupure des lignes \u00e0 valeur de la droite de l'\u00e9cran. :se ts= chiffre la valeur des tabulations est positionn\u00e9 \u00e0 chiffre caract\u00e8res (valeur par d\u00e9faut 8) :se nu affichage des num\u00e9rotations de lignes. :syntax on pour aciver la coloration syntaxique (avec vi ) Toutes ces commandes trouvent leur place dans le fichier d'initialisation de vi qui porte le nom \".exrc\" ou \".vimrc\" pour vim . Conclusions Vi est un \u00e9diteur puissant demandant de la pratique pour \u00eatre pleinement utilis\u00e9. Pour les allergiques \u00e0 vi , il existe aussi un autre \u00e9diteur : emacs . Toutes les possibilit\u00e9s n'ont pas \u00e9t\u00e9 abord\u00e9es ici. Pour plus d'informations se reporter \u00e0 la documentation de votre syst\u00e8me UNIX. Pipelines (tubes) Introduction Les pipe sont une fonctionnalit\u00e9 tr\u00e8s puissantes dans unix et dans le shell. Ils permettent de cr\u00e9er des commandes sophistiqu\u00e9es \u00e0 partir des commandes de base d'unix. Les sorties d'un processus peuvent \u00eatre redirig\u00e9es vers un fichier. Si un autre processus a besoin de ces donn\u00e9es \u00e0 l'entr\u00e9e on peut les lui donner par l'interm\u00e9daire d'un fichier. Exemple : $ ls fich1 $ wc -l fich1 # Compte le nombre de lignes,donc le nombre de fichier. 12 $ On peut aussi diriger directement les sorties d'un processus en entr\u00e9e d'un autre processus par l'interm\u00e9diaire d'un tube. Le symbole '|' permet de le faire. $ ls toto tata tutu $ # Nombre de fichiers dans le r\u00e9pertoire courant. $ ls | wc -l 3 $ Le symbole '|' indique au shell de prendre le r\u00e9sultat de la commande \"ls\" et de l'envoyer non pas sur l'\u00e9cran, mais sur l'entr\u00e9e de la commande \" wc \". La sortie de la commande \" wc \" n'\u00e9tant pas redirig\u00e9 (dans cet exemple) le r\u00e9sultat s'affiche \u00e0 l'\u00e9cran. La redirection des entr\u00e9es sorties permet d'orienter la commande vers un fichier. Les tubes (pipelines) permettent quand \u00e0 eux de regiriger la sortie d'un processus vers l'entr\u00e9e d'un autre processus. Les filtres. Les commandes se situant apr\u00e9s le caract\u00e8re '|' doivent \u00eatre des filtres, c'est \u00e0 dire qu'elles doivent prendre leurs donn\u00e9es depuis stdin et afficher le r\u00e9sultat sur stdout. Toutes les commandes ne sont pas des filtres. Les commandes \" cp \", \" mv \", \" who \", \" date \" ne sont pas des filtres, elles ne peuvent donc \u00eatre utilis\u00e9es en bout de tubes. Par contre la commande \" wc \" est un filtre. La commande sort Format : sort [-options] [ [ n1 [ n2 ] [ fich1 ..] [ fich2 ] Tri les lignes sur l'entr\u00e9e standard (ou fich1 ) et \u00e9crit le r\u00e9sultat sur la sortie standard (ou fich2 ). le tri est lexicographique sur l'ensemble des fichiers. options description -b les espaces de t\u00eate sont ignor\u00e9s dans les comparaisons. -d Seules les lettres,chiffres et espaces sont significatifs. -f Confond les lettres majuscules et minuscules. -i Ignore les caract\u00e8res ASCII non compris entre 32 et 126 -n le d\u00e9but des lignes num\u00e9riques sont tri\u00e9s num\u00e9riquement. -r Inverse l'ordre. -t x + n O\u00f9 x est un caract\u00e8res quelconque permettant de s\u00e9parer des champs dans des lignes, le tri s'effectue \u00e0 partir du n eme caract\u00e8re x trouv\u00e9. n1 - n2 Limite la comparaisons entre les colonnes n1 et n2-1 La commande \"sort\" poss\u00e8de de nombreuses autres options, se reporter \u00e0 la documentation de votre syst\u00e8me UNIX. Exemple : R\u00e9pertoire de num\u00e9ro de postes. $cat numpost gilbert:611:bureau de d\u00e9veloppement daniel:344:bureau d \u00e9tudes val\u00e9rie:312:sec\u00e9taire $ $ sort numpost # tri alphab\u00e9tique sur les lignes daniel:344:bureau d \u00e9tudes gilbert:611:bureau de d\u00e9veloppement val\u00e9rie:312:sec\u00e9taire $ $ sort -n -t: +1 numpost ; # tri num\u00e9rique sur le 2\u00e9me champ val\u00e9rie:312:sec\u00e9taire daniel:344:bureau d \u00e9tudes gilbert:611:bureau de d\u00e9veloppement $ La commande \"grep\" Format : grep [-options] ' motif ' [fich ...] La commande \" grep \" recherche dans les fichiers sp\u00e9cifi\u00e9s (ou stdin) le motif sp\u00e9cifi\u00e9et affiche ces lignes. Si la recherche s'effectue sur plusieurs fichiers \"grep\" affiche en d\u00e9but de ligne le nom du fichier. options description -n Imprime le num\u00e9ro de ligne et la ligne. -n Affiche les lignes ne contenant pas le motif sp\u00e9cifi\u00e9. -l Seuls les num\u00e9ros de lignes sont sp\u00e9cifi\u00e9s. -c Affiche uniquement le nombre de ligne contenant le motif le motif est \u00e9crit entre quotes \" ' \" . Exemple : $ grep -v bureau numpost val\u00e9rie:312:sec\u00e9taire $ tubes et redirections d'I/O Les redirections permet d'orienter la sortie d'un processus (c'est \u00e0 dire le resultat d'un programme), tandis que les tubes (pipelines) permettent de rediriger les sorties d'un processus vers l'entr\u00e9e d'un autre processus; c'est donc une communication entre processus. Exemples de tubes : $ ls | wc -l # donne le nombre de fichier dans le r\u00e9pertoire courant 32 $ ls .. | wc -l # donne le nombre de fichier dans le r\u00e9pertoire p\u00e8re 3 $ who | wc -l # donne le nombre de personnes connect\u00e9es 4 $ # Exemple de tube avec redirection. $ echo Nombre de gens connect\u00e9s \u00e0 la date de fich $ date fich $ echo -n est : fich $ who | wc -l fich $ cat fich Nombre de gens connect\u00e9s \u00e0 la date de Tue Jan 12 18 :43 GMT 1988 est 4 $ Quelques filtres usuels La commande \"pr\" Format : pr [-options] [fichier ...] La commande pr permet de formatter du texte sur la sortie standard. Sans option affiche avec un en-t\u00eate et une num\u00e9rotation de page. C'est une commande tr\u00e9s puissante. Quelques options : options description + n D\u00e9bute \u00e0 la page de num\u00e9ro donn\u00e9. - n Impression sur le nombre de colonnes donn\u00e9 (1 par d\u00e9faut). -m Imprime les fichiers \u00e0 raison de 1 par colonne. -d Ins\u00e8re une ligne blanche entre chaque ligne. -w n Largeur d'une ligne (72 par d\u00e9faut). -l n Chaque page contient n lignes. -h L'argument suivant est utilis\u00e9 comme en-t\u00eate \u00e0 chaque page -p Interruption entre chaque page ( cr pour continuer) -t Les 5 premi\u00e8res lignes de l'ent\u00eate ne sont pas imprim\u00e9es La commande \"paste\" Format : paste [options] [fichier ...] Les lignes de chaque fichier sont consid\u00e9r\u00e9es comme des colonnes s\u00e9par\u00e9es par d\u00e9faut par des tabulations. Exemple : $ cat fich1 aa ab ac $ cat fich2 ba bb bc $ paste fich1 fich2 aa ba ab bb ac bc $ La commande \"pg\" Format : pg [ n ] [-p chaine ] [-options] [ n ] [files...] Permet l'affichage de texte avec arr\u00eat entre chaque page et possibilit\u00e9 de retour arri\u00e8re. n Sp\u00e9cifie le nombre de ligne \u00e0 afficher.(par d\u00e9faut 23) -p chaine chaine est utilis\u00e9 comme prompt (par d\u00e9faut \":\") Quelques options: -c Efface l'\u00e9cran avant l'affichage de chaque page. -e Enl\u00e8ve l'arr\u00e8t entre chaque fichiers. + n1 Commence \u00e0 la ligne n1 Quelques commandes de \"pg\": cr affichage d'une nouvelle page. h Affiche une aide sur les commandes disponibles. ! commande Execute une commande du shell. La commande \"lp\" Format : lp [fichier...] Permet d'imprimer sur l'imprimante locale les fichiers sp\u00e9cifi\u00e9s (ou ce qui est \u00e9crit depuis l'entr\u00e9e standard, caract\u00e8re fin de fichier pour terminer). Le Shell,Programmation et Environnement L'environnement. Nous avons vu que lorsqu'un processus lance un autre processus, celui ci h\u00e9rite de l'environnement du processus qui l'a lanc\u00e9. L'\u00e9diteur vi utilise la variable TERM de l'environnement. L'environnement est constitu\u00e9 en grande partie de variables comme la variable TERM. Les programmes ont aussi des variables qui leur sont propres. On distingue deux types d'environnement : L'environnement global commun \u00e0 tous les processus. L'environnement local \u00e0 un processus. c'est l'environnement associ\u00e9 au processus. Certaines variables sont d\u00e9j\u00e0 d\u00e9finis et ont une utilisation sp\u00e9cifique. La commande \"set\" Permet d'avoir l'environnement local du shell en cours. $ set PATH = :/bin:/usr/bin TERM = vt100 HOME = /home/daniel PS1 = \\$ PS2 = $ PATH Sp\u00e9cifie les r\u00e9pertoires o\u00f9 seront cherch\u00e9s les commandes. Le caract\u00e8re \":\" \u00e9tant le s\u00e9parateur sauf le premier qui sp\u00e9cifie le r\u00e9pertoire courant. dans le cas pr\u00e9sent le shell ira chercher les programmes dans : le r\u00e9pertoire courant le r\u00e9pertoire /bin le r\u00e9pertoire /usr/bin TERM Sp\u00e9cifie le terminal qui est utilis\u00e9. HOME Le r\u00e9pertoire du login,c'est le r\u00e9pertoire qui est pris par la commande \"cd\". PS1 Le prompt du shell. PS2 Le deuxi\u00e8me prompt du shell La commande \"export\" Format : export variable [variables ...] Permet de rendre une variable globale. Les variables globales sont pass\u00e9es aux processus fils. $ VARIABLE_LOCALE = local $ VARIABLE_GLOBALE = global $ set | grep VARIABLE $ VARIABLE_LOCALE = local $ VARIABLE_GLOBALE = global $ export VARIABLE_GLOBALE $ sh $ set | grep VARIABLE $ VARIABLE_GLOBALE = global $ La commande \"env\" Permet d'avoir la liste des variables globales. Ces variables seront pass\u00e9es aux processus fils. Lorsqu'un processus fils est lanc\u00e9 il obtient une copie de l'environnement du p\u00e8re, toutes ces t\u00e2ches se feront dans cette copie. C'est pourquoi un processus fils ne peut pas modifier l'environnement du p\u00e8re. Il est impossible de faire un \"export\" ascendant du fils vers le p\u00e8re. Affectation des variables nom_de_variable = valeur Les noms de variable commencent par une lettre et sont compos\u00e9s de lettres, chiffres et du caract\u00e8res \"_\" On peut affecter \u00e0 une variable la valeur d'une autre variable, pour cela il faut faire pr\u00e9c\u00e9der cette derni\u00e8re par le caract\u00e8re \"\\$\". Si les variables se trouvent au milieu d'une ligne il faut entourer le nom de la variable par deux accolades \"{ }\". Exemple: $ VARL = locale $ echo $VARL locale $ echo La temp\u00e9rature $VARL est de 10 degr\u00e9s La temp\u00e9rature locale est de 10 degr\u00e9s $ echo Les temp\u00e9ratures ${ VARL } s sont chaudes Les temp\u00e9ratures locales sont chaudes $ Les caract\u00e8res sp\u00e9ciaux Nous avons vu d\u00e9j\u00e0 certains caract\u00e8res sp\u00e9ciaux, \\$ signifie que la suite est une variable d'environnement, les accolades {} permettent de d\u00e9limiter le nom d'une variable, l'espace est consid\u00e9r\u00e9 comme \u00e9tant le s\u00e9parateur. Il est parfois n\u00e9cessaire de pouvoir outrepasser un caract\u00e8re, Il existe trois moyens : \\ le caract\u00e8re backslash ou barre oblique inverse '' deux simples quotes \"\" deux guillemets Le backslash annihile le r\u00f4le d'un caract\u00e8re sp\u00e9cial. Exemple : \\\\$var ne sera pas interpr\u00e9t\u00e9 comme le contenu de la variable var mais comme la chaine \\$var . \\\\ donnera le caract\u00e8re \\ Les simples quotes sont utilis\u00e9s pour marquer plusieurs caract\u00e8res. Les guillemets annulent toutes interpr\u00e9tation des caract\u00e8res \u00e0 l'exception des caract\u00e8res : \\'\"\\$ dont l'interpr\u00e9tation peut \u00eatre annul\u00e9e s'ils sont pr\u00e9c\u00e9d\u00e9s de \\ Les noms implicites de fichiers Il existe un syst\u00e8me de g\u00e9n\u00e9ration de fichiers. Une partie du nom d'un fichier peut \u00eatre remplac\u00e9e par des caract\u00e8res jokers: caract\u00e8re(s) description * Remplace un nombre quelconque de caract\u00e8res. ? Remplace un seul caract\u00e8re. `[] D\u00e9fini une classe de caract\u00e8res. .. Une suite de caract\u00e8res. ! n\u00e9gation d'une classe de caract\u00e8res. Exemple: $ ls * ; # idem \u00e0 ls tout seul toto tata $ ls to* to $ ls t [ a-i ] t* tata $ ls t [ ao ] * toto tata $ Note : Les m\u00e9ta-caract\u00e8res ne d\u00e9tectent pas les fichiers commen\u00e7ant par le caract\u00e8re \".\". Le fichier .profile Lorsque que l'on se connecte, on se retrouve avec un certain environnement. Cet environnement peut \u00eatre modifi\u00e9 en modifiant le fichier .profile qui se trouve dans le r\u00e9pertoire par d\u00e9faut de l'utilisateur (rep\u00e9r\u00e9 par la variable d'environnment $HOME ). Les fichiers commen\u00e7ant par le caract\u00e8re \".\" n'apparassent pas avec la commande \"ls\" (il faut utiliser l'option -a ). Lors de la connexion le fichier .profile sera ex\u00e9cut\u00e9 par le shell. Exemple : $ cd $ echo echo Bonjour Daniel .profile $ exit login: daniel password: xxxxxxx Bonjour Daniel $ Introduction \u00e0 la programmation en shell Le shell est un langage de commande interpr\u00e9t\u00e9. Un programme shell est donc un fichier texte contenant un ensemble de commandes, Il est rendu ex\u00e9cutable par la commande \"chmod\". Le shell est un langage puissant mais est tr\u00e8s peu pratique pour les calculs arithm\u00e9tiques. Exemple de programme shell: $ cat dir ls -a $ dir . .. .profile dir $ De m\u00eame que pour les commandes on peut passer des param\u00e8tres aux programmes shell. les variables pass\u00e9es en param\u00e8tres sont de la forme \\$ n ou n est un chiffre. \\$0 est le nom du programme \\$1 \u00e0 \\$9 sont les arguments pass\u00e9s en param\u00e8tres. Exemple : $ cat mon_echo echo $0 $1 $mon_echo mon_echo Bonjour Bonjour $ $ cat rend_executable chmod +x $1 echo $1 est devenu un programme executable. $rend_executable dir dir est devenu un programme executable. $ On peut programmer directement en shell depuis la ligne de commande. Exemple: $ for i in 1 2 3 ; do echo bonjour ; done bonjour bonjour bonjour $ for i in 1 2 do echo bonjour done bonjour bonjour $ Ici nous avons ex\u00e9cut\u00e9 une boucle de deux mani\u00e8res diff\u00e9rentes. La premi\u00e8re fois nous avons \u00e9crit l'instruction compl\u00e8te, le shell l'a ex\u00e9cut\u00e9. La deuxi\u00e8me fois nous avons \u00e9crit l'instruction partiellement, le shell s'en rendant compte nous affiche le deuxi\u00e8me prompt (PS2) pour nous indiquer qu'il attendla suite de l'instruction pour l'ex\u00e9cuter. Se reporter \u00e0 la documentation UNIX pour avoir une description compl\u00e8te de possibilit\u00e9s du langage shell. Communications entre utilisateurs Introduction UNIX offre les possibilit\u00e9s suivantes: Messagerie \u00e9lectronique : envoi,r\u00e9ception de messages Gestion d'un journal de bord. Conversation en temps r\u00e9el. Messagerie. Au moment du login UNIX vous avertie, si vous avez du courrier par le message suivant : \"You have mail\" La commande \"mail\" Format : mail [-r] [-f fichier ] ou : mail nom [ nom ...] 9.2.1.1 Premi\u00e8re forme : Permet de lire son courrier, apr\u00e8s l'impression de chaque message la commande \"mail\" affiche le rompt \"?\" vous invitant\u00e0 taper une commande de \"mail\". options -r imprime les messages dans l'ordre d'arriv\u00e9e (par d\u00e9faut l'inverse). -f Permet de lire une boite aux lettres diff\u00e9rentes de la sienne ( \u00e0condition d'avoir les droits d'acc\u00e8s ) Les commandes: cr Passage au message suivant. idem. Passage au pr\u00e9c\u00e9dent. d Suppression du message courant et passage au suivant. S fichier Sauvegarde le message dans fichier . w fichier Sauvegarde le message dans fichier sans son en-t\u00eate. m nom ...Envoi le message en cours aux utilisateurs nom ... q Pour quitter la commande \"mail\". Ctrl-d idem. ! commande Permet d'ex\u00e9cuter une commande du shell h Aide de la commande \"mail\". Affiche la liste des commandes. 9.2.1.2 Deuxi\u00e8me forme: Envoi le message qui sera entr\u00e9au clavier aux utilisateurs nom ...Ceci m\u00eame si les utilisateurs ne sont pas connect\u00e9s au syst\u00e8me UNIX.Pour terminer entrez le caract\u00e8re fin de fichier (par d\u00e9faut Ctrl-d ) La commande \"mail\" peut\u00eatre avantageusement rediriger (pour l'entr\u00e9edu texte) La commande \"mailx\" La commande \"mailx\" est une mani\u00e8re plus agr\u00e9able d'examiner son courrier. Elle donne une liste num\u00e9rot\u00e9e des messages que vous n'avez pas encore lus. Vous pouvez lire un message en entrant son num\u00e9ro, chaque message \u00e0 un sujet. Chaque message lu passe de la boite au lettres syst\u00e8me \u00e0 un fichier appel\u00e9 \"mbox\" dans votre home directory (Le r\u00e9pertoire de login) Quelques options: -f fichier Lit les messages depuis fichier sinon depuis \"mbox\". -N n'affiche pas le sommaire. -n nom Lit les messages de nom si l'on a les droits d'acc\u00e8s. La commande \"mailx\" est plus sophistiqu\u00e9e que la commande \"mail\", se reporter \u00e0 la documentation UNIX pour plus de d\u00e9tails. Le journal de bord. UNIX permet de g\u00e9rer un v\u00e9ritable journal de bord. Les nouvelles sont stock\u00e9es dans le r\u00e9pertoire /usr/news. La commande \"news\" Format : news [options] [ fichiers ...] Permet de lire le journal de bord. options -a toutes les nouvelles sont supprim\u00e9es qu'elles aient ou non d\u00e9j\u00e0 \u00e9t\u00e9 consult\u00e9es par l'utilisateur. -n Les noms des nouvelles sont seules imprim\u00e9es. -s indique uniquement le nombre de nouvelles disponibles. La conversation en temps r\u00e9el UNIX permet \u00e0 deux utilisateurs connect\u00e9s au syst\u00e8me de converser en direct. La commande \"mesg\" Permet d'accepter ou de refuser les conversations en direct. Ceci est utile lorsque l'on travaille sous un \u00e9diteur par exemple pour \u00e9viter d'avoir des messages parasites. options: -y Accepte les messages. -n Refuse les messages. La commande \"write\" Format : write nom [ terminal ] Permet de communiquer directement avec un autre utilisateur si celui ci est connect\u00e9 et s'il accepte les messages (commande \"mesg\") Sur l' \u00e9cran du destinataire appara\u00eet le message suivant : \"message from ...\" La conversation se fait en direct jusqu'\u00e0que l'un des interlocuteurs appuie sur fin de fichier ( Ctrl-d ). Sauvegarde et archivage des fichiers. La commande \"find\" Format : find liste de chemins expressions Permet une recherche automatique de fichiers dans une partie de l'arborescence (recherche r\u00e9cursive) du syst\u00e8me de fichiers de UNIX. C'est une commande tr\u00e8s gourmande en temps CPU, \u00e0 utiliser avec mod\u00e9ration. liste de chemins est la liste des r\u00e9pertoires de recherches expressions D\u00e9fini le type de recherche. convention d' \u00e9critures: n sans signe signifie :\u00e9gale valeur n avec le signe plus signifie: sup\u00e9rieur ou \u00e9gal\u00e0n. n avec le signe moins signifie : inf\u00e9rieur ou \u00e9gal\u00e0n. options: -name nom Vrai si le fichier a pourr\u00e9f\u00e9rence nom -perm nombre en octal Vrai si le fichier a pour droit d'acc\u00e8s ... -type x Vrai si le type de fichier est x . x : b fichier sp\u00e9cial de type block c fichier sp\u00e9cial de type caract\u00e8re d fichier de type catalogue f fichier de type ordinaire. p pour les tubes nomm\u00e9s.(System III etV) -links n Vrai si le fichiera n liens. -user nom Vrai si le fichierapour propri\u00e9taire nom -group nom Idem pour le groupe d'utilisateur. -size n Vrai si le fichier a n blocs. -atime n Vrai si le fichier a \u00e9t\u00e9 consult\u00e9 depuis n jours -mtime n Vrai si le fichier a \u00e9t\u00e9 modifi\u00e9depuis n jours. -inum n Vrai si le fichier a pour i-node n . -print Affiche les noms des fichiers r\u00e9pondant \u00e0 expressions . Toutes ces primitives peuvent \u00eatre compos\u00e9es avec l'op\u00e9rateur de n\u00e9gation \"!\". La commande \"cpio\" C'est la commande de sauvegarde des fichiers et des r\u00e9pertoires. Elle s'emploie selon trois formes, par d\u00e9faut la commande attend la liste des fichiers \u00e0 sauvegarder depuis l'entr\u00e9e standard ( Ctrl-d pour terminer). Elle s'utilise le plus souvent avec la commande \"find\". cpio -p directory Format : cpio -p [adlmruv] r\u00e9pertoire Lit la liste des fichiers \u00e0 sauvegarder sur l'entr\u00e9e standard et les sauvegarde dans r\u00e9pertoire . cpio -o (output = sortie) Format : cpio -o [aBcv] copie les fichiers sur la sortie standard en indiquant le chemin et le statuts. cpio -i (input = entr\u00e9e) Format : cpio -i [BcdmrtuvfsSb] [patterns] Lit l'entr\u00e9e standard et recr\u00e9e la structure de l'arborescence indiqu\u00e9e par l'entr\u00e9e. Les options: a Remet \u00e0 0 les temps d'acc\u00e8s des fichiers d'entr\u00e9es. B l'entr\u00e9e et la sortie se font par bloc de 5120 octets (A n'utiliser qu'avec redirection sur des devices par blocs, des lecteurs de bandes par exemple). d Les r\u00e9pertoires sont cr\u00e9\u00e9s s'il y a lieu. c Ecrit l'en-t\u00eate en ASCII (pour la portabilit\u00e9). r Renomme les fichiers (de mani\u00e8re interactive) t Affiche la liste des fichiers d'entr\u00e9es (Rien n'est cr\u00e9\u00e9, utile pour v\u00e9rifier que tout c'est bien pass\u00e9). u copie inconditionnelle (normalement les fichiers plus anciens ne remplacent pas les fichiers plus jeunes). v affiche sur la sortie une liste des fichiers affich\u00e9s. l Essaye de cr\u00e9er des liens plut\u00f4t que la recopie des fichiers. f copie tout les fichiers sauf ceux d\u00e9finis dans [patterns] s \u00e9change l'ordre des octets. S \u00e9change l'ordre des demi-mots. b \u00e9quivalent aux options s et S. La commande \"tar\" Format : tar [ cl\u00e9s ] [ fichiers ...] Permet d'archiver des fichiers sur un fichier unique sur bande magn\u00e9tique, ainsi que leur restitutions cl\u00e9s Permet de contr\u00f4ler le type d'op\u00e9ration : r Ecriture des fichiers en fin de bande. x Extraction des fichiers de la bande, si le nom est un r\u00e9pertoire il est cr\u00e9\u00e9 et les caract\u00e9ristiques des fichiers sont respect\u00e9s si possibles. t Liste les fichiers de la bande sans extraction. u Sauvegarde les fichiers en fin de bande s'ils n'y sont pas d\u00e9j\u00e0. c Cr\u00e9ation d'une nouvelle bande.(sauvegarde en d\u00e9but de bande) Les param\u00e8tres des cl\u00e9s sont les suivants: 0..7 S\u00e9lectionne le d\u00e9rouleur de bande. v Le nom de chaque fichier est affich\u00e9 w Avant chaque op\u00e9ration affiche le fichier en cours et demande confirmation \u00e0 l'utilisateur. f Le nom de l'argument suivant est utilis\u00e9 comme r\u00e9f\u00e9rence du fichier d'archive.(Par d\u00e9faut c'est /dev/rmt0 (d\u00e9rouleur de bande 0) m Demande la non-restitution de la date,la date courante est alors utilis\u00e9e. z Compresse ou d\u00e9compresse les donn\u00e9es suivant les cas Note Il n'y a pas de caract\u00e8re \"-\" au d\u00e9but des options !!. Si le nom du fichier avec l'option f est \"-\" c'est la sortie standard qui est utilis\u00e9e. Exemple: r\u00e9copie du r\u00e9pertoire courant vers un autre endroit $ tar cf - . | ( cd /tmp ; tar xvf - ) La commande \"ar\" Format : ar [options] nom de librairie [ liste-de-fichiers ] Permet d'archiver des fichiers et de cr\u00e9er des biblioth\u00e8ques de fichiers objets (pour les compilateurs.) options: -d supprime les fichiers sp\u00e9cifi\u00e9s de la biblioth\u00e8que. -r Remplace les fichiers sp\u00e9cifi\u00e9 dans la biblioth\u00e8que. -q Rajout des fichiers en fin de biblioth\u00e8que. -t Impression du contenu des fichiers de la biblioth\u00e8que ou de la liste des fichiers -p Impression des modules de la biblioth\u00e8que. -m d\u00e9placement des modules en fin de biblioth\u00e8que. -x Extraction des fichiers de la biblioth\u00e8que. -v option d'affichage d\u00e9taill\u00e9. La commande \"cmp\" Format : cmp [option] fichier1 fichier2 Permet de comparer deux fichiers. options : -l Toutes les diff\u00e9rences sont signal\u00e9es par le num\u00e9ro du caract\u00e8re en d\u00e9cimal et sa valeur en octal. -s aucune sortie, la commande est utilis\u00e9e pour avoir un code de sortie. Commandes additionnelles La commande \"crypt\" Permet de coder un fichier, affiche sur la sortie standard le fichier cod\u00e9. Les fichiers sont cod\u00e9 par un algorithme en fonction de la cl\u00e9 que vous donnez. La commande \"od\" Format : od [options] fichier Permet de r\u00e9aliser un \"dump\" du fichier sp\u00e9cifi\u00e9.(par d\u00e9faut en octal.) . options: -b Les mots sont interpr\u00e9t\u00e9s en octal -c les octets sont interpr\u00e9t\u00e9s en ASCII -d Les mots sont interpr\u00e9t\u00e9s en d\u00e9cimal -o Les mots sont interpr\u00e9t\u00e9s en octal -x les mots sont interpr\u00e9t\u00e9s en hexad\u00e9cimal La commande \"touch\" Format : touch [options] [date] fichier ... Permet de changer la date de derni\u00e8re modification des fichiers sp\u00e9cifi\u00e9s. Si aucune date n'est donn\u00e9e, la date courante est utilis\u00e9e. options: -a Change la date d'acc\u00e8s. -m Change la date de modification. -c Emp\u00eache la fonction \"touch\" de cr\u00e9er le fichier si celui-ci n'existe pas. La commande \"split\" Format : split [- n ] [ fichier [ nom ] ] Permet de d\u00e9couper un fichier en plusieurs fichiers. Par d\u00e9faut d\u00e9coupe le fichier toute les 1000 lignes si - n n'est pas sp\u00e9cifi\u00e9 . Les fichiers de sorties ont pour nom nom avec les lettres 'aa' \u00e0 'zz' (au maximum 676 fichiers) Si nom n'est pas sp\u00e9cifi\u00e9 \"x\" est pris par d\u00e9faut. Les commandes d'administration du syst\u00e8me. La commande \"su\" Permet de passer en mode super-utilisateur(Plus de protection dans le syst\u00e8me UNIX, \u00e0 condition d'avoir le mot de passe. Plut\u00f4t remplac\u00e9 par sudo qui permet de donner des acc\u00e8s \u00e0 certaines commandes \u00e0 un utilisateur donn\u00e9 sans que celui-ci ne connaisse le mot de passe de root. DE nos jours on \u00e9vtite de passer en root directement, on passe plut\u00f4t par la commande sudo qui permet de donner des droits plus fin aux utilisateurs. La commande \"sar\": Permet d'avoir des renseignements sur l'activit\u00e9 du syst\u00e8me UNIX. Se reporter \u00e0 la documentation UNIX pour plus de d\u00e9tails. La commande \"sysadm\" \"sysadm\" est une interface pour g\u00e9rer le syst\u00e8me. (administration du syst\u00e8me.). n\u00e9cessite de conna\u00eetre le mot de passe. Se reporter \u00e0 la documentation pour plus de d\u00e9tails. La commande de configuration du terminal \"stty\" Format : stty [-a][-g] [options] La commande \"stty\" permet de conna\u00eetre l'\u00e9tat du param\u00e9trage de la ligne du terminal ainsi que de le reconfigurer. Sans arguments donne l'\u00e9tat de la ligne. -a donne l'\u00e9tat complet de la ligne. -g donne l'\u00e9tat de la ligne dans un format permettant de configurer un autre terminal (via les tubes). Sans \"-\" pour actionn\u00e9 l'option, Avec \"-\" pour la d\u00e9sactiver. Les modes de contr\u00f4les parenb autorise le contr\u00f4le de parit\u00e9. parodd parit\u00e9 impaire cs5 cs6 cs6 cs8 Nombre de bits de donn\u00e9es. 50..300...1200..9800 Vitesse de transmission de la ligne. cstopbutilise 1 bits de stop (sinon 2) Les modes d'entr\u00e9e ignbrk ignore le break; ignpar ignore les erreurs de parit\u00e9. istrip compacte sur 7 bits les donn\u00e9es. inclr le caract\u00e8re New-line est interpr\u00e9t\u00e9 comme return icrnl le return est interpr\u00e9t\u00e9 comme new-line iuclc Interpr\u00e8te les majuscules comme des minuscules. ixon Autorise le contr\u00f4le de flux ( Ctrl-s ) ixany Tout caract\u00e8re relance l'affichage (sinon uniquement Ctrl-q ) ixoff Le syst\u00e8me envoie des START/STOP suivant l'\u00e9tat des buffers Les modes de sortie opost Les caract\u00e8res en sortie doivent \u00eatre traiter (par l'une des options suivantes) olcuc identifie les minuscules en majuscules onlcr new-line comme la suite return new-line onocr les return en t\u00eate de ligne sont ignor\u00e9s. onlret sur le terminal new-line est interpr\u00e9t\u00e9 comme return Les modes locaux echo envoie l'\u00e9cho de chaque caract\u00e8re echoe l'\u00e9cho du caract\u00e8re erase est la suite backspace espace backspace icanonles caract\u00e8res sont entr\u00e9s en modes lignes d\u00e9limit\u00e9s par new-line noflshne vide pas les buffers apr\u00e8s une interruption INTR, QUIT, ou SWTCH isig Autorise le test des caract\u00e8res en entr\u00e9e pour d\u00e9tecter les interruptions INTR,QUIT,SWTCH Se reporter \u00e0 la documentation pour une information plus d\u00e9taill\u00e9e.","title":"Unix"},{"location":"unix/#systeme-unix-niveau-1","text":"SUIVI DES VERSIONS DU DOCUMENT Creation : 1988/01/20 Last changes : 2019/10/07 corrections mineures 2018/09/07 passage en markdown Syst\u00e8me UNIX niveau 1 Pr\u00e9face Notations Avertissement. Introduction Qu'est ce que UNIX Historique Avant Linux Description g\u00e9n\u00e9rale Principales caract\u00e9ristiques du syst\u00e8me UNIX Portabilit\u00e9 Premier contact avec UNIX Session utilisateur Proc\u00e9dure d'entr\u00e9e sous UNIX Manipulations des commandes UNIX Proc\u00e9dure d'arr\u00eat d'une commande Proc\u00e9dure de sortie d'UNIX Premi\u00e8res Commandes. La commande \"banner\" La commande \"logname\" La commande \"who\" La commande \"passwd\" La commande \"echo\" La commande \"man\" Le shell Le syst\u00e8me de fichiers Qu'est ce qu'un fichier Pr\u00e9sentation g\u00e9n\u00e9rale R\u00e9f\u00e9rence des fichiers et r\u00e9pertoire de travail La protection des fichiers Les commandes de manipulations de fichiers. La commande \"pwd\" La commande \"cd\" La commande \"ls\" La commande \"cat\" La commande \"cp\" La commande \"ln\" La commande \"mv\" La commande \"rm\" La commande \"mkdir\" La commande \"rmdir\" Modification des caract\u00e9ristiques d'un i-node La commande \"chgrp\" La commande \"chown\" La commande \"chmod\" Les entr\u00e9es-sorties, M\u00e9canismes de redirection La commande \"wc\" Fichiers et processus G\u00e9n\u00e9ralit\u00e9s et pr\u00e9sentation La commande \"ps\" Le Shell Lancement d'un processus en arri\u00e8re plan La Commande \"nohup\" La commande \"wait\" La commande \"nice\" La commande \"at\" Destruction d'un processus La commande \"kill\" Editeur de texte vi Introduction \u00e0 vi Appel de l'\u00e9diteur. Les commandes de vi La touche Esc Pour sortir de l'\u00e9diteur Commandes G\u00e9n\u00e9rales D\u00e9placement du curseur Commandes de suppression de texte. Commandes de recherche (cha\u00eene de caract\u00e8res) Commandes d'insertion Commandes de modification Commandes de r\u00e9cup\u00e9ration Quelques commandes particuli\u00e8res Conclusions Pipelines (tubes) Introduction Les filtres. La commande sort La commande \"grep\" tubes et redirections d'I/O Quelques filtres usuels La commande \"pr\" La commande \"paste\" La commande \"pg\" La commande \"lp\" Le Shell,Programmation et Environnement L'environnement. La commande \"set\" La commande \"export\" La commande \"env\" Affectation des variables Les caract\u00e8res sp\u00e9ciaux Les noms implicites de fichiers Le fichier .profile Introduction \u00e0 la programmation en shell Communications entre utilisateurs Introduction Messagerie. La commande \"mail\" La commande \"mailx\" Le journal de bord. La commande \"news\" La conversation en temps r\u00e9el La commande \"mesg\" La commande \"write\" Sauvegarde et archivage des fichiers. La commande \"find\" La commande \"cpio\" cpio -p directory cpio -o (output = sortie) cpio -i (input = entr\u00e9e) Les options: La commande \"tar\" La commande \"ar\" La commande \"cmp\" Commandes additionnelles La commande \"crypt\" La commande \"od\" La commande \"touch\" La commande \"split\" Les commandes d'administration du syst\u00e8me. La commande \"su\" La commande \"sar\": La commande \"sysadm\" La commande de configuration du terminal \"stty\" Les modes de contr\u00f4les Les modes d'entr\u00e9e Les modes de sortie Les modes locaux","title":"Syst\u00e8me UNIX niveau 1"},{"location":"unix/#preface","text":"","title":"Pr\u00e9face"},{"location":"unix/#notations","text":"Durant tout ce cours nous utiliserons les notations suivantes : Pour indiquer qu'il faut appuyer sur la touche \"retour chariot\" ou \"Enter\" nous noterons \" cr \" . Pour indiquer \"control d\" : Appui simultan\u00e9 de la touche \"Control\" et de la touche \" d \" nous noterons \" Ctrl-d \". Pour la description de la syntaxe d'une commande, les termes optionnels seront plac\u00e9s entre crochets :\" [Termes optionnels] \". Les noms des fichiers seront mis entre guillemets.","title":"Notations"},{"location":"unix/#avertissement","text":"Ce cours ne constitue pas un manuel UNIX, nous ne pr\u00e9senterons pas toutes les commandes UNIX, mais uniquement les principales pour d\u00e9marrer. Nous ne ferons pas une description exhaustive des commandes, mais donnerons uniquement la syntaxe et les options les plus couramment utilis\u00e9es. Pour tout compl\u00e9ment d'information, se reporter aux manuels d'Unix fournis avec le mat\u00e9riel.","title":"Avertissement."},{"location":"unix/#introduction","text":"","title":"Introduction"},{"location":"unix/#quest-ce-que-unix","text":"UNIX est un syst\u00e8me d'exploitation, multi-taches, multi-utilisateurs. Il se situe entre l'utilisateur et la machine. Utilisateur Syst\u00e8me d'exploitation Hardware de la machine Le syst\u00e8me est charg\u00e9 du partage \u00e9quitable des ressources de la machine entre chaque utilisateur. Le syst\u00e8me d'exploitation n\u00e9gocie entre les d\u00e9sirs de l'utilisateur et les ressources ou les performances de la machine. Les demandes : ex\u00e9cuter des commandes. cr\u00e9er des fichiers. entrer dans un r\u00e9seau. etc ... Les ressources : l'unit\u00e9 centrale, la m\u00e9moires, les Disques, le r\u00e9seau, etc...","title":"Qu'est ce que UNIX"},{"location":"unix/#historique","text":"Le syst\u00e8me d'exploitation UNIX a \u00e9t\u00e9 d\u00e9velopp\u00e9 par les laboratoires BELL, d\u00e9pendant de AT T (American Telephone Telegraph), l'un des plus grands centres de recherche au monde. Son cr\u00e9ateur est KEN THOMPSON, il en a assur\u00e9 la conception en 1969. Depuis cette date, beaucoup de chercheurs, d'ing\u00e9nieurs ont contribu\u00e9 \u00e0 son enrichissement, \u00e0 son \u00e9volution. Le d\u00e9veloppement du langage C par DENNIS RITCHIE a permis l'\u00e9criture d'une version dans ce langage de haut niveau, par cons\u00e9quent portable \u00e0 priori sur tout type de machine disposant d'un compilateur C. *\"SYSTEM 3\" est apparu en 1981, et marque la double volont\u00e9 de AT T de: Se lancer dans une action commerciale de grande envergure, r\u00e9agir contre les d\u00e9rives des diff\u00e9rents portages d'UNIX, et conduisant \u00e0 certaines incompatibilit\u00e9s. * La derni\u00e8re version, \"SYSTEM V\", est le fruit d'efforts importants durant plusieurs ann\u00e9es, entrepris par AT T et par l'universit\u00e9 de BERKELEY, en Californie, principalement. Les domaines concern\u00e9s sont avant tout la gestion des fichiers et la fiabilit\u00e9 d'Unix. \"SYSTEM V\" apparu en 1983, marque la volont\u00e9 de AT T d'imposer cette version, tant aux constructeurs d'ordinateurs qu'aux soci\u00e9t\u00e9s de logiciels qui se rallient massivement \u00e0 ce standard, tout en r\u00e9alisant un certain nombre d'ajouts li\u00e9s \u00e0 des \u00e9quipements particuliers et/ou \u00e0 des logiciels existants. Ces diff\u00e9rences sont valid\u00e9es par AT T. Il existe une quarantaine de \"versions diff\u00e9rentes\" du syst\u00e8me UNIX... Ce nombre, inqui\u00e9tant de prime abord lorsque l'on a des soucis de portabilit\u00e9, de compatibilit\u00e9, que signifie-t-il au juste? pourquoi toutes ces versions? Qu'est-ce-que cela cache? Pourquoi toutes ces versions ? Il convient d'aborder ce point selon deux axes: historique et commercial.","title":"Historique"},{"location":"unix/#avant-linux","text":"De nos jours, Unix est plut\u00f4t connu via Linux et ses multiples distributions. UNIX est apparu en 1969. UNIX a \u00e9volu\u00e9 dans le temps et les diff\u00e9rentes versions de r\u00e9f\u00e9rence (d\u00e9nomm\u00e9es dans tout ce qui suit AT T-UNIX), ont marqu\u00e9 les grandes \u00e9tapes de cette \u00e9volution: Version 5 (1973) Version 6 (1975) Version 7 (1979) Syst\u00e8me III (1981) Syst\u00e8me V (1983) Chacune de ces versions techniques au-del\u00e0 de la \"Version 7\" a donn\u00e9 naissance \u00e0 des versions commerciales. AT T, qui est propri\u00e9taire de la marque UNIX (UNIX est une marque d\u00e9pos\u00e9e) passe des contrats avec des constructeurs, des soci\u00e9t\u00e9s de d\u00e9veloppement, qui adaptent AT T UNIX, en y int\u00e9grant souvent tout ou partie des utilitaires d\u00e9velopp\u00e9s par l'universit\u00e9 de BEKELEY, aux caract\u00e9ristiques des mat\u00e9riels. Les versions ainsi adapt\u00e9es doivent obligatoirement avoir un nom commercial diff\u00e9rent d'UNIX, d'ou les nombreuses appellations. En voici une liste non exhaustive: XENIX de MICROSOFT (1) VENIX de VENTURE COM's (1) ZEUS de ZILOG (1) UNIPLUS de UNISOFT SYSTEMS (1) IDRIS de WHITE SMITHS (2) SOL de ADI INRIA ET SYSECA (2) INITY de DIGITAL EQUIPEMENT CORPORATION (3) IS/WB de INTERACTIVE SYSTEMS (3) (1) Authentique versions issues de BELL et comportant des variantes adapt\u00e9es en g\u00e9n\u00e9ral, pour tenir compte des diff\u00e9rences de mat\u00e9riels. (2) Syst\u00e8mes d'exploitation, de type UNIX, enti\u00e8rement r\u00e9\u00e9crits et offrant des possibilit\u00e9s identiques ou tr\u00e8s proches de celles d'UNIX. (3) Syst\u00e8mes d'exploitation, de type UNIX, fonctionnant sous le contr\u00f4le du syst\u00e8me d'exploitation de l'ordinateur h\u00f4te, offrant un environnement quasi-identique \u00e0 celui de AT T UNIX.","title":"Avant Linux"},{"location":"unix/#description-generale","text":"UNIX est un syst\u00e8me d'exploitation multi-t\u00e2che, multi- utilisateur fonctionnant en temps partag\u00e9. Les programmes dont il assure le contr\u00f4le peuvent \u00eatre lanc\u00e9s en mode interactif ou en traitement batch. L'une des caract\u00e9ristiques principales d'UNIX par rapport au syst\u00e8me d'exploitation traditionnel est la gestion de tout p\u00e9riph\u00e9rique d'entr\u00e9e-sorties sous la forme d'un fichier. La gestion de l'ensemble de ces fichiers repr\u00e9sente un syst\u00e8me de gestion de fichiers hi\u00e9rarchis\u00e9s sous la forme d'un arbre. Cette possibilit\u00e9 permet ainsi de rediriger tous les r\u00e9sultats issus d'un programme comme param\u00e8tre d'entr\u00e9e d'un autre programme. De plus UNIX est fourni avec un ensemble d'utilitaires de base ainsi que d'une documentation en ligne. UNIX est aussi un syst\u00e8me de d\u00e9veloppement, donnant aux utilisateurs tous les outils permettant d'\u00e9crire, de mettre au point et de documenter leurs programmes. Le syst\u00e8me UNIX est compos\u00e9 : d'un noyau assurant la gestion de la m\u00e9moire et des entr\u00e9es sorties de bas niveau ainsi que de l'encha\u00eenement des diff\u00e9rentes t\u00e2ches . d'un (ou plusieurs suivant les versions) interpr\u00e9teur de commandes. d'un syst\u00e8me de messageries assez complet (courrier, conversation en temps r\u00e9el ) d'un grand nombre d'utilitaires, dont un compilateur de langage C, un g\u00e9n\u00e9rateur d'analyseur syntaxique lex, un g\u00e9n\u00e9rateur d'analyseur s\u00e9mantique yakk, etc ...","title":"Description g\u00e9n\u00e9rale"},{"location":"unix/#principales-caracteristiques-du-systeme-unix","text":"Ses principales caract\u00e9ristiques sont : Son syst\u00e8me de fichiers hi\u00e9rarchis\u00e9s (voir Chap 3) L'aspect multi-t\u00e2ches pour chaque utilisateur. La possibilit\u00e9s d'\u00e9crire des applications faisant directement appel au noyau par l'interm\u00e9diaire du langage C. Ses langages de commandes qui sont de v\u00e9ritables langages de programmation interpr\u00e9t\u00e9s, permettant l'\u00e9criture de programmes complexes. Son m\u00e9canisme de re-directions des entr\u00e9es sorties. En effet tout processus prend normalement ses donn\u00e9es depuis le clavier du terminal par lequel il a \u00e9t\u00e9 lanc\u00e9, de m\u00eame que ses sorties se font normalement sur l'\u00e9cran, il est possible d'associer aux entr\u00e9es sorties des fichiers quelconques ( UNIX consid\u00e9rant toutes les entr\u00e9es-sorties comme des fichiers sur lesquels il peut lire ou \u00e9crire ). UNIX allant plus loin puisque les sorties d'un programme peuvent \u00eatre consid\u00e9r\u00e9s comme les entr\u00e9es d'un autre programme.(communication entre processus par l'interm\u00e9diaire de tube, \"pipe\" en anglais).","title":"Principales caract\u00e9ristiques du syst\u00e8me UNIX"},{"location":"unix/#portabilite","text":"Un certain nombre de constructeurs ont port\u00e9 UNIX sur leurs mat\u00e9riels : Digital, Bull, Hewlett Packard, Thompson, Cray, Apple..., ceci dans une gamme variant du micro-ordinateur au plus gros syst\u00e8me. L'une des facilit\u00e9s de la portabilit\u00e9 d'UNIX est le fait que 95% environ du syst\u00e8me est \u00e9crit dans un langage de haut niveau : Le langage C, les 5% restant \u00e9tant \u00e9crit en assembleur, ceci pour g\u00e9rer les drivers d'entr\u00e9e-sortie dans les couches les plus basses. Avec l'arriv\u00e9e de \"SYSTEM V\", l'utilisateur a pu modifier certains param\u00e8tres syst\u00e8me auxquels il n'avait pas acc\u00e8s sous \"System III\". Les logiciels serveur sont donc portables sur toutes les machines impl\u00e9ment\u00e9es avec le syst\u00e8me d'exploitation UNIX system V.","title":"Portabilit\u00e9"},{"location":"unix/#premier-contact-avec-unix","text":"","title":"Premier contact avec UNIX"},{"location":"unix/#session-utilisateur","text":"Une session utilisateur commence par un \"login\" (entr\u00e9e dans le syst\u00e8me) et se termine par un \"login off\" (sortie du syst\u00e8me), entre les deux on peut ex\u00e9cuter des commandes, obtenir des r\u00e9ponses de la part de l'ordinateur. Une commande \u00e9tant le seul moyen d'effectuer quelque chose sur l'ordinateur. Une commande est un programme que l'on utilise pour faire une t\u00e2che d\u00e9sir\u00e9e. La commande est ex\u00e9cut\u00e9e en entrant son nom au clavier suivi de cr .","title":"Session utilisateur"},{"location":"unix/#procedure-dentree-sous-unix","text":"Pour d\u00e9marrer une session utilisateur il faut poss\u00e9der un \"login id\" (id pour identificateur) et \u00e9ventuellement un mot de passe. Au message \"login:\" envoy\u00e9 par le syst\u00e8me, l'utilisateur doit saisir son \"login-id\". Ensuite au message \"password:\" il doit saisir son mot de passe. Si le nom et le mot de passe sont corrects l'utilisateur peut alors d\u00e9marrer sa session de travail sur la machine. Il est recommand\u00e9 d'entrer son \"login-id\" en minuscules, sinon UNIX (qui fait la diff\u00e9rence entre majuscules et minuscules) consid\u00e9rera que votre console ne reconna\u00eet pas les minuscules et vous affichera tout en majuscules. Exemple : login :daniel lt ; cr gt ; password : xxxxxxxxxx le mot de passe n est pas affich\u00e9 \u00e0 l \u00e9cran pour des raisons \u00e9videntes de s\u00e9curit\u00e9. Bienvenue sous 3B15 == Message de bienvenue. $ A l'entr\u00e9e sur le syst\u00e8me on obtient un prompt (par d\u00e9faut le caract\u00e8re \"\\$\") indiquant que UNIX est pr\u00eat \u00e0 acc\u00e9der \u00e0 tous vos d\u00e9sirs (ou presque). Un certain nombre de noms d'utilisateurs sont requis par le syst\u00e8me pour g\u00e9rer des taches particuli\u00e8res. Ces taches sont avant tout des taches syst\u00e8mes et administratives, ex : root est le super-utilisateur du syst\u00e8me, il a tous les droits (d'o\u00f9 la n\u00e9cessit\u00e9 de prot\u00e9ger son utilisation par l'interm\u00e9diaire d'un mot de passe).","title":"Proc\u00e9dure d'entr\u00e9e sous UNIX"},{"location":"unix/#manipulations-des-commandes-unix","text":"Pour ex\u00e9cuter une commande sous UNIX, il suffit d'entrer son nom (Premier mot de la ligne entr\u00e9e) ainsi que des options dont elle a \u00e9ventuellement besoin. Format d'une ligne de commande : cmd [arg ...] cr cmd est le nom de la commande. arg repr\u00e9sente les param\u00e8tres optionnels de la commande. Chaque param\u00e8tre \u00e9tant s\u00e9par\u00e9 par un espace. Exemple avec la commande 'date La commande date permet d'afficher la date et l'heure du syst\u00e8me sur lequel vous \u00eates connect\u00e9s. Il y a une option pour date permettant de changer la date du syst\u00e8me mais elle n'est accessible que pour le super-utilisateur. $ date Mon Jan 11 14 :55:15 GMT 1988 $","title":"Manipulations des commandes UNIX"},{"location":"unix/#procedure-darret-dune-commande","text":"Il est possible d'arr\u00eater le d\u00e9roulement d'une commande avant son terme. Par d\u00e9faut il s'agit de la combinaison de touches \"Ctrl-C\" la touche Control avec la touche C . L'utilisateur a la possibilit\u00e9 de changer cette touche.","title":"Proc\u00e9dure d'arr\u00eat d'une commande"},{"location":"unix/#procedure-de-sortie-dunix","text":"Pour terminer une session de travail il suffit d'envoyer le caract\u00e8re fin de fichier qui est par d\u00e9faut le caract\u00e8re \" \". Une autre possibilit\u00e9 est d'entrer la commande exit. Exemple : login :daniel password : xxxxxxxxx Bienvenue sous 3B15 $ date Mon Jan 11 14 :55:15 GMT 1988 Ctrl-d login :","title":"Proc\u00e9dure de sortie d'UNIX"},{"location":"unix/#premieres-commandes","text":"","title":"Premi\u00e8res Commandes."},{"location":"unix/#la-commande-banner","text":"Imprime ses arguments en gros caract\u00e8res. Elle est utilis\u00e9e pour l'\u00e9tiquetage, ou le titrage en sortie. $ banner Hello # # # # ###### # # #### # # # # # # # ####### ##### # # # # # # # # # # # # # # # # # # # # ###### ###### ###### #### $","title":"La commande \"banner\""},{"location":"unix/#la-commande-logname","text":"La commande logname vous donne votre nom d'utilisateur.","title":"La commande \"logname\""},{"location":"unix/#la-commande-who","text":"La commande who permet de savoir qui est connect\u00e9 sur le syst\u00e8me. Avec les options \" am i \" ou \" am I \" permet de savoir qui on est. $ who am i daniel tty Tue 17 :44","title":"La commande \"who\""},{"location":"unix/#la-commande-passwd","text":"Permet de changer son mot de passe. Entrer la commande passwd , elle vous demandera votre nouveau mot de passe et de le confirmer; si tout se passe bien votre nouveau mot de passe sera valide pour votre prochaine session.","title":"La commande \"passwd\""},{"location":"unix/#la-commande-echo","text":"Ecrit ses arguments et passe a la ligne suivante. Passe \u00e0 la ligne si elle n'a aucun argument. La commande reconna\u00eet quelques caract\u00e8res sp\u00e9ciaux: caract\u00e8res description \\b backspace : retour arri\u00e8re \\c Affiche la ligne sans passer \u00e0 la ligne \\f form feed : efface l'\u00e9cran \\n New line: passe \u00e0 la ligne \\t tabulation \\v tabulation verticale \\ le caract\u00e8re Sur les versions de linux il faut activer les caract\u00e8res sp\u00e9ciaux via l'option -e .","title":"La commande \"echo\""},{"location":"unix/#la-commande-man","text":"Si l'on n'a pas le manuel sous la main. man permet de savoir ce que fait tel ou tel commande, ainsi que les options de la commande. l'option \"-k\" suivi de mots cl\u00e9s affiche un r\u00e9sum\u00e9 des commandes pass\u00e9es en arguments. Pour savoir comment marche la commande man entrer : $ man man","title":"La commande \"man\""},{"location":"unix/#le-shell","text":"Le shell est l'interpr\u00e9teur de commandes. Il existe plusiseurs interpr\u00e9teur de commandes : sh , ksh , csh , bash , bash \u00e9tant le plus r\u00e9pandu de nos jours. Il interpr\u00e8te ce que vous tapez au clavier pour l'ex\u00e9cuter. Lorsque vous tapez un retour-chariot il interpr\u00e8te le texte que vous avez \u00e9crit et ex\u00e9cute la commande dont le nom est le premier mot de la ligne. C'est lui qui vous affiche le prompt (par d\u00e9faut \"\\$\") vous invitant \u00e0 taper quelque chose.","title":"Le shell"},{"location":"unix/#le-systeme-de-fichiers","text":"","title":"Le syst\u00e8me de fichiers"},{"location":"unix/#quest-ce-quun-fichier","text":"Un fichier est un lieu de stockage d'informations, c'est un nom et des donn\u00e9es associ\u00e9es. Par exemple la commande date est un nom et un fichier programme associ\u00e9. Un terminal est un fichier sur lequel on peut \u00e9crire : l'\u00e9cran, et sur lequel on peut lire : le clavier. UNIX consid\u00e8re toutes les entr\u00e9es/sorties comme des fichiers, donc: les programmes, les p\u00e9riph\u00e9riques, les donn\u00e9es sont tous consid\u00e9r\u00e9s comme des fichiers. Sous unix un fichier peut avoir plusieurs noms (Voir la commande ln ).","title":"Qu'est ce qu'un fichier"},{"location":"unix/#presentation-generale","text":"Un fichier sous unix est une cha\u00eene de caract\u00e8res non structur\u00e9e du point de vue du syst\u00e8me. UNIX ne poss\u00e8de aucune notion d'organisation de fichiers telle que les fichiers s\u00e9quentiels, index\u00e9s, partitionn\u00e9s. A tout fichier est associ\u00e9 un bloc d'information : le i-node contenant un certain nombre d'informations sur celui-ci : sa taille. l'adresse des blocs sur le disque o\u00f9 les donn\u00e9es sont r\u00e9ellement \u00e9crites. l'identification du propri\u00e9taire. Un compteur de r\u00e9f\u00e9rence dans le syst\u00e8me. un certains nombre de dates relatives au fichier. On remarquera que ce bloc ne contient aucun nom d'identification pour le fichier. Les noms sont gard\u00e9s dans des fichiers sp\u00e9cifiques : Les catalogues (ou r\u00e9pertoires ou encore directories). Sous UNIX il existe trois types de fichiers : Les fichiers ordinaires ( type data, texte, ou binaire). Les fichiers directory (r\u00e9pertoire ou catalogue en fran\u00e7ais). Les fichiers sp\u00e9ciaux. Il s'agit des fichiers drivers (exemple le disque, le terminal). Il existe deux types de fichiers sp\u00e9ciaux : Les fichiers sp\u00e9ciaux de type caract\u00e8res (Le terminal) Les fichiers sp\u00e9ciaux de type blocs (Le disque) Un fichier est r\u00e9f\u00e9renc\u00e9 par un nom dans une directory. Un m\u00eame fichier peut \u00eatre r\u00e9f\u00e9renc\u00e9 plusieurs fois dans diff\u00e9rents catalogues. Le catalogue \u00e9tant lui m\u00eame r\u00e9f\u00e9renc\u00e9 dans un autre catalogue. Cette architecture n\u00e9cessite l'existence d'un r\u00e9pertoire sp\u00e9cial dont le syst\u00e8me conna\u00eet l'emplacement, il s'agit du r\u00e9pertoire racine not\u00e9 \" / \". La structure des fichiers sous UNIX est donc une arborescence, on trouvera sous celui-ci des r\u00e9pertoires commun \u00e0 tous les syst\u00e8mes UNIX.","title":"Pr\u00e9sentation g\u00e9n\u00e9rale"},{"location":"unix/#reference-des-fichiers-et-repertoire-de-travail","text":"Architecture de l'arborescence des fichiers sous UNIX. / / usr / bin / etc / dev / tty1 / home / daniel Le syst\u00e8me de fichiers forme une arborescence, les noeuds sont des catalogues et les feuilles des fichiers ou des catalogues vides. Nous pouvons nous d\u00e9placer dans cette arborescence au moyen de certaines commandes. Le nom d'un fichier peut \u00eatre donn\u00e9 soit par sa r\u00e9f\u00e9rence absolue c'est \u00e0 dire son nom complet depuis la racine, soit par sa r\u00e9f\u00e9rence relative c'est \u00e0 dire par rapport au r\u00e9pertoire sur lequel on se trouve. Par convention une r\u00e9f\u00e9rence relative est une r\u00e9f\u00e9rence ne commen\u00e7ant pas par le caract\u00e8re \" / \". Le rep\u00e9rage des fichiers est facilit\u00e9 par l'existence dans toutes les directories de deux r\u00e9f\u00e9rences particulieres qui sont : . et .. point et point point, ils d\u00e9signent respectivement le r\u00e9pertoire courant et le r\u00e9pertoire au dessus ou pr\u00e9c\u00e9dent avec une exception pour le r\u00e9pertoire racine qui d\u00e9signe alors lui m\u00eame. Exemple , si nous sommes dans le r\u00e9pertoire /home/daniel r\u00e9f\u00e9rence designation /home/daniel/toto.c R\u00e9f\u00e9rence absolue au fichier toto.c se trouvant dans le r\u00e9pertoire /home/daniel ../daniel/toto.c R\u00e9f\u00e9rence relative par rapport au r\u00e9pertoire courant (on remonte d'un cran et on redescend) toto.c R\u00e9f\u00e9rence relative par rapport au r\u00e9pertoire courant . d\u00e9signe /home/daniel .. d\u00e9signe le r\u00e9pertoire parent : /home Tous les fichiers commen\u00e7ant par le caract\u00e8re . n'apparaissent pas avec les commandes normales d'affichage des fichiers, ils sont consid\u00e9r\u00e9s comme des fichiers cach\u00e9s. Tous les utilisateurs poss\u00e9dent leur propre r\u00e9pertoire de travail qui est par d\u00e9faut le repertoire courant au moment du \"login\". Il existe quelques r\u00e9pertoires communs \u00e0 tous les syst\u00e8mes UNIX. r\u00e9pertoire description / La racine du syst\u00e8me /usr Contient ce qui est utilis\u00e9 par l'utilisateur : compilateurs, librairies, etc. /bin et /usr/bin Contient les programmes associ\u00e9s aux commandes UNIX /dev contient les fichiers sp\u00e9ciaux /etc contient les fichiers syst\u00e8mes /tmp tous les fichiers temporaires","title":"R\u00e9f\u00e9rence des fichiers et r\u00e9pertoire de travail"},{"location":"unix/#la-protection-des-fichiers","text":"Sous UNIX tout utilisateur poss\u00e8de, associ\u00e9 \u00e0 son identification un num\u00e9ro de compte et appartient \u00e0 un groupe d'utilisateur. Ainsi pour un fichier donn\u00e9 les utilisateurs peuvent \u00eatre class\u00e9s en trois cat\u00e9gories : Le propri\u00e9taire du fichier (Celui qui l'a cr\u00e9\u00e9). Les membres du groupe du propri\u00e9taire. tous les autres. Sans oublier le super-utilisateur root, qui lui, a tous les droits. Trois contr\u00f4les \u00e9l\u00e9mentaires sont faits par le syst\u00e8me: Les droits de lecture (repr\u00e9sent\u00e9 par r pour r ead) Les droits d'\u00e9criture ( repr\u00e9sent\u00e9 par w pour w rite) Les droits d'ex\u00e9cution(repr\u00e9sent\u00e9 par x pour e x ecution Pour un r\u00e9pertoire : Le droit d'ex\u00e9cution signifie la possibilit\u00e9 pour un utilisateur de se positionner sur ce r\u00e9pertoire (en fait plut\u00f4t de le traverser). Le droit de lecture \u00e9tant de lire le contenu du r\u00e9pertoire. Le droit d'\u00e9criture donne la possibilit\u00e9 de cr\u00e9er des fichiers dans celui-ci ainsi que d'effacer des fichiers dans ce r\u00e9pertoire m\u00eame si l'on n'a pas les droits d'\u00e9criture sur ces fichiers. Il existe aussi trois autres bits de contr\u00f4les sur les fichiers qui ont un r\u00f4le sp\u00e9cial: le set-uid : Lorsqu'il est positionn\u00e9 donne \u00e0 l'utilisateur du programme les droits du cr\u00e9ateur du programme et non ceux de l'utilisateur du programme. le set-guid : Idem \u00e0 set-uid mais au niveau du groupe. le sticky-bit : qui permet au contr\u00f4leur de processus de garder ce programme en m\u00e9moire (RAM) m\u00eame si d'autres en ont besoin.","title":"La protection des fichiers"},{"location":"unix/#les-commandes-de-manipulations-de-fichiers","text":"Nous allons voir ici les principales commandes permettant de manipuler les fichiers et les r\u00e9pertoires.","title":"Les commandes de manipulations de fichiers."},{"location":"unix/#la-commande-pwd","text":"Affiche le nom du repertoire courant \u00e0 partir de la racine. $ pwd /home/daniel $","title":"La commande \"pwd\""},{"location":"unix/#la-commande-cd","text":"Permet de changer de r\u00e9pertoire de travail courant. Sans param\u00e9tre permet de revenir au r\u00e9pertoire par d\u00e9faut du login (attention, celui-ci peut \u00eatre chang\u00e9). Exemple: $ pwd /home/daniel $ cd /usr/bin # Positionnement absolu $ pwd /usr/bin $ cd ../include # Positionnement relatif $ pwd /usr/include $ cd # Sans param\u00e8tre retour au pwd : HOME directory /u1/daniel $","title":"La commande \"cd\""},{"location":"unix/#la-commande-ls","text":"Format : ls [-options] [arg] Permet d'afficher la liste des fichiers dans le r\u00e9pertoire courant ou le r\u00e9pertoire pass\u00e9 en argument. quelques options: -l affiche en format long (donne plus d'informations) donnant: le mode du fichier et le type. le nombre de liens.(nombre de r\u00e9f\u00e9rences du fichier) le propri\u00e9taire. le groupe du propri\u00e9taire. la taille (en octets) la date de derni\u00e8re modification. le nom -o identique \u00e0 -l mais sans le groupe. -g identique \u00e0 -l mais sans le propri\u00e9taire. -t impression avec tri dans l'ordre des modifications (derni\u00e8res en t\u00eate) -a tout les noms des fichiers sont imprim\u00e9s alors que par d\u00e9faut les fichiers commen\u00e7ant par le caract\u00e8re \".\" ne sont pas affich\u00e9s. -d si l'argument est un r\u00e9pertoire seul son nom est affich\u00e9. -r l'ordre d'impression est invers\u00e9 (quelque soit le tri ) -u le tri est fait selon les dates de consultation. -i pour chaque fichier affiche son num\u00e9ro d'i-node Avec l'option -l la commande ls affiche les protections appliqu\u00e9es aux entr\u00e9es (r\u00e9pertoire, fichiers, fichiers sp\u00e9ciaux) dans l'ordre suivant: type de fichier (un caract\u00e8re) un groupe de 3 caract\u00e8re pour le propri\u00e9taire un groupe de 3 caract\u00e8res pour le groupe un groupe de 3 caract\u00e8res pour le reste du monde les protections sont positionn\u00e9es de la mani\u00e8re et dans l'ordre suivant, ceci pour chaque type d'utilisateur : r autorise la lecture- sinon w autorise l'\u00e9criture- sinon x autorise l'ex\u00e9cution - sinon type de fichiers fichier normal d fichier directory l lien symbolique c fichier sp\u00e9cial de type caract\u00e8res b fichier sp\u00e9cial de type blocs p sur UNIX system III et V indique les tubes nomm\u00e9s Si le set-uid est positionn\u00e9 le caract\u00e8re \" s \" sera \u00e9crit au lieu de \" x \" dans les droits d'ex\u00e9cution du propri\u00e9taire. Si le set-guid est positionn\u00e9 le caract\u00e8re \" s \" sera \u00e9crit au lieu de \" x \" dans les droits d'ex\u00e9cution du groupe. Si le sticky-bit est positionn\u00e9 le caract\u00e8re \" t \" sera \u00e9crit au lieu de \" x \" dans les droits d'ex\u00e9cution des autres.","title":"La commande \"ls\""},{"location":"unix/#la-commande-cat","text":"Format : cat \\[arg ...\\] Permet d'afficher \u00e0 l'\u00e9cran le contenu des fichiers pass\u00e9s en arguments.","title":"La commande \"cat\""},{"location":"unix/#la-commande-cp","text":"Format : cp fichier-source fichier-dest Permet de dupliquer des fichiers. \"cp\" effectue la copie physique du premier argument dans le second. Il y a cr\u00e9ation d'un nouvel i-node et recopie effective des donn\u00e9es. Exemple : $ pwd # affiche le r\u00e9pertoire courant /home/daniel $ ls # pas de fichier dans le repertoire $ cat toto un contenu dans le fichier Ctrl-d # appui sur la touche Control et sur la touche D $ ls toto $ cp toto tutu $ ls toto tutu $","title":"La commande \"cp\""},{"location":"unix/#la-commande-ln","text":"Format : ln fichier-source fichier-dest Permet de cr\u00e9er des liens. Nous avons vu qu'un m\u00eame fichier peut avoir plusieurs noms mais correspondre au m\u00eame bloc de donn\u00e9es sur le disque. Il n'y a pas cr\u00e9ation d'un nouvel i-node. il n'y a pas de de duplication des donn\u00e9es. Exemple: $ ls -il 8122435 -rw------- 1 daniel daniel 27 Janv 13 18 :04 toto $ cp toto tata $ ls -il 8122489 -rw------- 1 daniel daniel 27 Janv 13 18 :14 tata 8122435 -rw------- 1 daniel daniel 27 Janv 13 18 :04 toto $ ln tata tatalinked $ ls -il 8122489 -rw------- 2 daniel daniel 27 Janv 13 18 :14 tata 8122489 -rw------- 2 daniel daniel 27 Janv 13 18 :14 tatalinked 8122435 -rw------- 1 daniel daniel 27 Janv 13 18 :04 toto $ # le fichier tatalinked est une r\u00e9f\u00e9rence au fichier tata, $ # il n y a pas duplication de donn\u00e9es $","title":"La commande \"ln\""},{"location":"unix/#la-commande-mv","text":"Format : mv fichier-source fichier-destination Change le nom d'un lien. il n'y a pas recopie physique mais uniquement modification du nom.","title":"La commande \"mv\""},{"location":"unix/#la-commande-rm","text":"Format : rm [-options] arg [arg...] Efface les fichiers sp\u00e9cifi\u00e9s par les arguments pass\u00e9s en param\u00e9tre. Les options : -i affiche chaque nom des fichiers demand\u00e9s et demande la confirmation de la suppression (appui sur \"y\" pour oui) -r provoque la suppression de tous les fichiers dans toutes les directories et sous directories sp\u00e9cifi\u00e9es de mani\u00e8re recursive ( attention tr\u00e9s dangereux, \u00e0 manier avec pr\u00e9cautions !) On ne peut pas effacer un r\u00e9pertoire avec la commande \"rm\" sans l'option -r .","title":"La commande \"rm\""},{"location":"unix/#la-commande-mkdir","text":"Format : mkdir arg [arg...] Permet de cr\u00e9er des r\u00e9pertoires.","title":"La commande \"mkdir\""},{"location":"unix/#la-commande-rmdir","text":"Format : rmdir arg [arg...] Permet de supprimer des r\u00e9pertoires. Les r\u00e9pertoires ne seront supprim\u00e9s que si ils sont vides. $ pwd /home/daniel $ ls -d $ mkdir dir1 dir2 $ ls toto tata dir1 dir2 $ mv tata dir1 $ ls toto dir1 dir2 $ls dir1 tata $ rmdir dir2 dir1 dir1 : directory not empty $ rm dir1/* $ rmdir dir1 $ ls toto $","title":"La commande \"rmdir\""},{"location":"unix/#modification-des-caracteristiques-dun-i-node","text":"Le propri\u00e9taire d'un fichier peut modifier le nom du propri\u00e9taire, du groupe, et des droits d'acc\u00e9s des diff\u00e9rents utilisateurs de ce fichier et lui seul (Avec le super-utilisateur). Les commandes sont : chmod, chown, chgrp.","title":"Modification des caract\u00e9ristiques d'un i-node"},{"location":"unix/#la-commande-chgrp","text":"Format : chgrp group file [file...] Change le groupe pour les fichiers sp\u00e9cifi\u00e9s. le groupe peut \u00eatre donn\u00e9 par son num\u00e9ro ou par son nom.","title":"La commande \"chgrp\""},{"location":"unix/#la-commande-chown","text":"Format : chown nom file [file...] Change le propi\u00e9taire des fichiers sp\u00e9cifi\u00e9s.le nom peut \u00eatre donn\u00e9 par son num\u00e9ro ou par son nom lit\u00e9ral.","title":"La commande \"chown\""},{"location":"unix/#la-commande-chmod","text":"Format : chmod mod file [file...] Permet de modifier les bits de protection des fichiers. Les modes peuvent \u00eatre d\u00e9crits en octal ou en symbolique. format de mode en symbolique: [ qui ] perm op qui u propri\u00e9taire (user) g groupe o autres (other) a pour tous (all) perm + rajoute la permision - enleve la permission = impose les permission (absolu) op r lecture w \u00e9criture x ex\u00e9cution t pour le \"sticky-bit\" s pour le \"set-uid\" bit (associ\u00e9 \u00e0 u) ou le \"set-guid\" (associ\u00e9 \u00e0 g)","title":"La commande \"chmod\""},{"location":"unix/#les-entrees-sorties-mecanismes-de-redirection","text":"Certaines commandes ne produisent pas de sortie, comme la commande cp sauf s'il y a une erreur, d'autres font uniquement des sorties sur l'\u00e9cran du terminal telles que date , who , ls ... Certaines font des lectures en entr\u00e9e. En fait tout programme sous UNIX connait TROIS types de fichiers qui sont : stdin : Fichier standard d'entr\u00e9e (par d\u00e9faut le clavier du terminal) stdout : Fichier standard de sortie (par d\u00e9faut l'\u00e9cran du terminal) stderr : Fichier standard d'affichage des erreurs (Par d\u00e9faut l'\u00e9cran du terminal) Les entr\u00e9es sorties \u00e9tant des fichiers il est possible de les rediriger vers d'autres fichiers ( fichiers data, fichiers devices ) de telle sorte qu'au lieu d'utiliser le terminal les programmes peuvent aller lire ou \u00e9crire leurs donn\u00e9es sur des fichiers. La redirection des entr\u00e9es sorties est g\u00e9r\u00e9e par le shell. Les commandes de redirection, file d\u00e9signant le nom d'un fichier : symbole entr\u00e9e/sortie description file stdout redirige vers le fichier sp\u00e9cifi\u00e9, si ce dernier existe il est tronqu\u00e9 \u00e0 z\u00e9ro caract\u00e8re sinon il est cr\u00e9\u00e9e. file stdout Idem sauf si le fichier existe les donn\u00e9es sont rajout\u00e9es en fin de celui-ci. 2 file stderr Idem \u00e0 pour la sortie d'erreur 2 file stderr Idem \u00e0 pour la sortie d'erreur file stdin les donn\u00e9es sont lues depuis le fichier sp\u00e9cifi\u00e9 TOTO stdin lit depuis l'entr\u00e9e standard courante jusqu'\u00e0 trouver la cha\u00eene TOTO, TOTO pouvant \u00eatre remplac\u00e9 par les caract\u00e8res de votre choix. cmd1 | cmd2 stdout vers stdin Permet d'enchainer 2 commandes, la sortie standard de la commande cmd1 devenant l'entr\u00e9e standard de cmd2","title":"Les entr\u00e9es-sorties, M\u00e9canismes de redirection"},{"location":"unix/#la-commande-wc","text":"Format : wc [option] Permet suivant l'option de compter le nombre de mots,de lignes, de caract\u00e9res lus au clavier jusqu'\u00e0 rencontrer le caract\u00e8re de fin de fichier Ctrl-d . Les options : -l compte le nombres de lignes. -w compte le nombre de mots -c compte le nombre de caract\u00e9res. sans option c'est -lwc qui est pris. Exemple: $ ls toto $ date fich1 $ ls toto fich1 $ cat fich1 Mon Jan 11 17 :38 GMT 1988 wc -l fich1 1 $","title":"La commande \"wc\""},{"location":"unix/#fichiers-et-processus","text":"","title":"Fichiers et processus"},{"location":"unix/#generalites-et-presentation","text":"Un processus est l'ex\u00e9cution d'un programme \u00e0 un instant donn\u00e9, le fichier programme \u00e9tant un objet inerte rang\u00e9 sur disque. On peut distinguer deux types de processus : Les processus syst\u00e8mes qui ne sont attach\u00e9s \u00e0 aucun type de terminal, qui sont cr\u00e9\u00e9s au lancement du syst\u00e8me ou \u00e0 des dates fixes. Les premiers ne s'arr\u00eatant qu'avec l'arr\u00eat du syst\u00e8me. Les processus lanc\u00e9s par un utilisateur particulier depuis un terminal donn\u00e9. Le fait de se 'loguer' cr\u00e9e un processus correspondant \u00e0 l'ex\u00e9cution d'un programme d\u00e9termin\u00e9 \u00e0 l'avance pour chaque utilisateur. La plupart du temps il s'agit de l'ex\u00e9cution de l'interpr\u00e9teur de commande : le shell. Un point fondamental pour un processus est l'environnement. Chaque processus a un environnement dont il h\u00e9rite du processus qui l'a lanc\u00e9 : le processus p\u00e8re. Par exemple vous lancez la commande \"rm\", votre shell g\u00e9n\u00e8re un nouveau processus qui sera cr\u00e9\u00e9 pour ex\u00e9cuter le programme qui effectue la tache d'effacement de fichiers. Ce nouveau processus h\u00e9rite de l'environnement de votre shell en particulier du r\u00e9pertoire courant o\u00f9 vous vous trouvez au moment du lancement de la commande. Chaque processus est identifi\u00e9 par son \"process-id\" (PID) le num\u00e9ro du processus p\u00e8re \u00e9tant identifi\u00e9 par le PPID. La diff\u00e9rence entre le processus p\u00e8re et le fils est que l'\u00e2ge a effet sur sa priorit\u00e9; en particulier la destruction du processus p\u00e8re entra\u00eene la destruction de tous ses processus fils (par d\u00e9faut).","title":"G\u00e9n\u00e9ralit\u00e9s et pr\u00e9sentation"},{"location":"unix/#la-commande-ps","text":"Format : ps [options] Permet d'avoir la liste des processus en cours dans le syst\u00e8me. \" ps \" sans argument donne la liste des processus attach\u00e9s \u00e0 votre terminal. Quelques options: -e informations sur tous les processus en cours sur la machine. -a information sur les processus associ\u00e9s aux terminaux. -f liste toutes les informations sur les processus. -l liste longue des informations. -t suivi d'une liste de num\u00e9ro donne la liste des processus associ\u00e9s \u00e0 ces terminaux. Ex: ps -t tty05,tty10 donne la liste des processus attach\u00e9s aux terminaux tty05 et tty10. D\u00e9tails sur les informations fournies par ps. PID num\u00e9ro du processus. PPID num\u00e9ro du processus p\u00e8re. TTY Terminal auquel est rattach\u00e9 le processus. TIME Dur\u00e9e cumul\u00e9e d'ex\u00e9cution. COMMAND Commande qui a \u00e9t\u00e9 ex\u00e9cut\u00e9e. UID num\u00e9ro du propri\u00e9taire du processus. CT aux d'utilisation de la CPU (Utilis\u00e9 pour le calcul de la priorit\u00e9 du processus). PRI Priorit\u00e9 du processus, les chiffres les plus hauts correspondants aux priorit\u00e9s les plus faibles. STIME Heure de lancement du processus.","title":"La commande \"ps\""},{"location":"unix/#le-shell_1","text":"Le shell est un processus important, tout utilisateur qui se connecte a sa copie du programme \"sh\" qui s'ex\u00e9cute dans son environnement. On peut Empiler plusieurs shells pour travailler sous diff\u00e9rents environnements. Si l'on tape \"sh\" on lance un nouveau processus. Exemple : login: daniel password: Bienvenue sous UNIX $ ps PID TTY TIMECOMMAND 745 4500 :06 sh 850 4500 :01 ps $ sh $ ps PID TTY TIMECOMMAND 745 4500 :08 sh 860 4500 :06 sh 865 4500 :01 ps $ On a deux shells qui s'ex\u00e9cutent en m\u00eame temps. Si l'on se d\u00e9logue en entrant Ctrl-d on obtient : $ Ctrl-d $ ps PID TTY TIMECOMMAND 745 4501 :10 sh 956 4500 :01 ps $ Ctrl-d login: Autre exemple : Environnement d'un processus. $ pwd /home/daniel $ sh $ pwd /home/daniel # On h\u00e9rite de l environnement du p\u00e8re. $ cd /usr/include $ pwd /usr/include $ Ctrl-d ; $ pwd /home/daniel # Mais pas l inverse : l environnement du fils n est pas transmis au p\u00e8re. $","title":"Le Shell"},{"location":"unix/#lancement-dun-processus-en-arriere-plan","text":"Le shell qui cr\u00e9e un processus en arri\u00e8re plan reprend la main sans attendre que celui-ci soit termin\u00e9. $ps PID TTY TIMECOMMAND 745 4500 :06 sh 850 4500 :01 ps $ ls -al fich1 800 $ ps -edf PID TTY TIMECOMMAND 745 4500 :06 sh 800 4500 :01 ls -al fich1 850 4500 :01 ps $ C'est le caract\u00e8re \" \" qui permet de lancer des processus en arri\u00e8re plan. Quand un processus est lanc\u00e9 en arri\u00e8re plan le shell renvoie le num\u00e9ro de process qui lui a \u00e9t\u00e9 attribu\u00e9. Attention un processus lanc\u00e9 en arri\u00e8re-plan (background) est quand m\u00eame d\u00e9truit en cas de d\u00e9connexion car il reste attach\u00e9 au terminal d'o\u00f9 il a \u00e9t\u00e9 lanc\u00e9. De plus un processus en arri\u00e8re plan a les m\u00eames entr\u00e9es-sorties que le processus p\u00e8re, il est donc conseill\u00e9 de rediriger les sorties, sinon les messages appara\u00eetront au fur et \u00e0 mesure sur le terminal.","title":"Lancement d'un processus en arri\u00e8re plan"},{"location":"unix/#la-commande-nohup","text":"Format : nohup commande [args] La commande \" nohup \" permet de d\u00e9tacher un processus du terminal.On pourra donc lancer de longs travaux sans monopoliser le terminal puisque les processus lanc\u00e9s par l'interm\u00e9diaire de la commande \"nohup\" seront d\u00e9tach\u00e9s du terminal, on pourra se d\u00e9connecter, nos processus continuerons \u00e0 tourner. Si l'on ne redirige pas les sorties la commande les redirigera vers un fichier nomm\u00e9 \"nohup.out\". $ nohup ps -efl fich1 850 $ ps PID TTY TIMECOMMAND 745 4500 :06 sh 850 4500 :01 nohup ps -efl fich1 980 4500 :01 ps $","title":"La Commande \"nohup\""},{"location":"unix/#la-commande-wait","text":"La commande wait attend la fin des processus lanc\u00e9s en arri\u00e8re plan.","title":"La commande \"wait\""},{"location":"unix/#la-commande-nice","text":"Format : nice [-increment] commande [args...] Permet de changer artificiellement la priorit\u00e9 d'un processus. On ne peut pas augmenter sa priorit\u00e9, mais seulement la baisser (sauf le super-utilisateur). Cela permet d'effectuer des travaux non-urgents en arri\u00e8re-plan. La priorit\u00e9 par d\u00e9faut est 10. La valeur d'incr\u00e9ment est comprise entre 1 et 19 (plus faible).","title":"La commande \"nice\""},{"location":"unix/#la-commande-at","text":"Format : at heure jour [ fichier ] Permet de lancer une commande en arri\u00e8re plan \u00e0 une date et une heure fix\u00e9es. La commande n'est pas attach\u00e9 \u00e0 un terminal (comme pour la commande \"nohup\". heure form\u00e9 de 1 \u00e0 4 chiffres peut \u00eatre suivi des lettres : a : am p : pm n : midi m : minuit jour est optionnel (par d\u00e9faut le jour courant) $ # Lance la commande ls -l fich \u00e0 18:00h le 15 janvier. $ at 18 jan 15 ls -l fich $","title":"La commande \"at\""},{"location":"unix/#destruction-dun-processus","text":"Le fait de se d\u00e9connecter tue tous les processus attach\u00e9s au terminal. Autrement il faut utiliser la commande kill . Si l'on n'a plus la main sur son terminal pour une raison ou une autre on peut toujours se connecter par l'interm\u00e9diaire d'un autre terminal.","title":"Destruction d'un processus"},{"location":"unix/#la-commande-kill","text":"Format : kill [-num\u00e9ro] PID [PID...] Permet de tuer des processus. Le num\u00e9ro de signal est compris entre 1 et 15. Le signal n\u00b0 2 correspond \u00e0 INTR Le signel n\u00b0 3 correspond \u00e0 QUIT L'arme absolue contre les processus r\u00e9calcitrants est : kill -9 PID Ceci \u00e0 condition d'\u00eatre le propri\u00e9taire du processus ou d'\u00eatre le super-utilisateur.","title":"La commande \"kill\""},{"location":"unix/#editeur-de-texte-vi","text":"","title":"Editeur de texte vi"},{"location":"unix/#introduction-a-vi","text":"Vi est un \u00e9diteur de texte pleine page. Il \u00e0 \u00e9t\u00e9 d\u00e9velopp\u00e9 \u00e0 l'Universit\u00e9 de Berkeley, mais est n\u00e9anmoins disponible sur la plupart des versions de UNIX. Ces principales caract\u00e9ristiques sont : Un syst\u00e8me de r\u00e9cup\u00e9ration et de sauvegarde sophistiqu\u00e9. Poss\u00e8de les m\u00eames possibilit\u00e9s que l'\u00e9diteur ligne ed. Poss\u00e8de un jeu de commandes puissant. Travaille sur une image m\u00e9moire du fichier \u00e9dit\u00e9. Vi \u00e9tant un \u00e9diteur pleine page, il utilise les attributs vid\u00e9o du terminal, qu'il conna\u00eet par l'interm\u00e9diaire de la variable TERM de l'environnement. L'initialisation de la variable se fait par : $ TERM = valeur $ export TERM $","title":"Introduction \u00e0 vi"},{"location":"unix/#appel-de-lediteur","text":"Il existe plusieurs fa\u00e7on d'appeler l'\u00e9diteur: vi nom : \u00e9dite le fichier et place le curseur sur la 1ere colonne de la 1ere ligne. vi +n nom : \u00e9dite le fichier et place le curseur sur la 1ere colonne de la ligne n. vi + nom : \u00e9dite le fichier et place le curseur sur la 1ere colonne de la derni\u00e8re ligne. vi +/ chaine / nom / : \u00e9dite le fichier et place le curseur sur le premier caract\u00e8re de la ligne contenant la premi\u00e8re occurrence de chaine Il est possible de cr\u00e9er un fichier qui sera ex\u00e9cut\u00e9 \u00e0 chaque appel de vi ce fichier doit avoir comme nom \".exrc\" dans le r\u00e9pertoire priv\u00e9 de l'utilisateur. Si ce fichier existe il sera consid\u00e9r\u00e9 comme un ensemble de commandes \u00e0 ex\u00e9cuter.","title":"Appel de l'\u00e9diteur."},{"location":"unix/#les-commandes-de-vi","text":"L'\u00e9diteur poss\u00e8de deux modes de travail : le mode insertion : tout ce qui entr\u00e9 au clavier est \u00e9crit dans le tampon en m\u00e9moire associ\u00e9 au fichier. Le mode commande : dans lequel tout ce qui est entr\u00e9 au clavier est interpr\u00e9t\u00e9 comme une commande de l'\u00e9diteur. le mode commande \u00e9tendue (commandes commen\u00e7ant par ':')","title":"Les commandes de vi"},{"location":"unix/#la-touche-esc","text":"Permet de sortir du mode insertion et de passer en mode commande.","title":"La touche Esc"},{"location":"unix/#pour-sortir-de-lediteur","text":"ZZ sort de l'\u00e9diteur et sauvegarde les modifications (deux fois la touche )","title":"Pour sortir de l'\u00e9diteur"},{"location":"unix/#commandes-generales","text":"on commence toujours par appyer sur Esc , cela ne fait pas de mal et on est sur de sortir du mode insertion. commande description :f donne la r\u00e9f\u00e9rence du fichier en cours d'\u00e9dition. ZZ ou :wq Sort de l'\u00e9diteur et sauvegarde les modifications. :w Sauvegarde du fichier sous son nom d'entr\u00e9e. :w nom Sauvegarde le fichier sous le nom nom ,le nom du tampon courant n'est pas modifi\u00e9. :w! Force l'\u00e9criture (utile dans certains cas). :q Sortie de l'\u00e9diteur,possible uniquement s'il n'y a pas eu modification. :q! Force la sortie sans modification. :e nom \u00e9dite le fichier nom uniquement si l'ancien est sauvegard\u00e9. :e! nom force l'\u00e9dition du nouveau fichier. :w n1 , n2 nom \u00e9crit uniquement les lignes comprises entre n1 et n2. :r nom introduit le fichier nom en dessous de la ligne courante. :r! commande introduit le r\u00e9sultat de la commande shell commande apr\u00e8s la ligne courante. :! commande Ex\u00e9cute la commande du shell commande Ctrl-l Rafra\u00eechissement de l'\u00e9cran. Utile lorsque le r\u00e9sultat d'op\u00e9ration provoque des affichages parasites. :se nu Affiche les num\u00e9ros de ligne en d\u00e9but de chaque... ligne (:se nonu pour les enlever) \u200b","title":"Commandes G\u00e9n\u00e9rales"},{"location":"unix/#deplacement-du-curseur","text":"Dans les commandes qui suivent n d\u00e9signe un facteur de r\u00e9p\u00e9tition il peut \u00eatre omis (de nos jours les fl\u00eaches fonctionnent tr\u00e8s bien). commande description n h d\u00e9place le curseur vers la gauche. n espace ou n l (L minuscule) d\u00e9place le n Ctrl-n ou n j d\u00e9place le curseur vers le bas. n Ctrl p ou n k d\u00e9place le curseur vers le haut. n + ou n cr descend le curseur de n lignes. n w d\u00e9place le curseur en d\u00e9but de mot suivant. n b d\u00e9place le curseur en d\u00e9but de mot pr\u00e9c\u00e9dent. n e d\u00e9place le curseur en fin de mot courant. n G d\u00e9place le curseur \u00e0 la ligne sp\u00e9cifi\u00e9. (par d\u00e9faut en fin de texte.) n Ctrl-u remonte de n lignes.(par d\u00e9faut \u00e0 une demi-page) n Ctrl-e descend de n lignes.(par d\u00e9faut \u00e0 une demi-page)","title":"D\u00e9placement du curseur"},{"location":"unix/#commandes-de-suppression-de-texte","text":"Dans les commandes qui suivent n d\u00e9signe un facteur de r\u00e9p\u00e9tition il peut \u00eatre omis. commande description n x supprime le caract\u00e8re sous le curseur. n X supprime le caract\u00e8re pr\u00e9c\u00e9dent le curseur. D supprime la fin de la ligne. n d w supprime le mot. n d d supprime la ligne.","title":"Commandes de suppression de texte."},{"location":"unix/#commandes-de-recherche-chaine-de-caracteres","text":"commande description n f car recherche du premier car sur la fin de la ligne courante et se positionne dessus. n F car recherche du premier car sur le d\u00e9but de la ligne courante et se positionne dessus. n t car recherche du premier car sur la fin de la ligne courante et se positionne sur le caract\u00e8re pr\u00e9c\u00e8dent. n T car recherche du premier car sur le d\u00e9but de la ligne courante et se positionne sur le caract\u00e8re pr\u00e9c\u00e8dent. n ; r\u00e9p\u00e8te l'une des op\u00e9rations f , F , t ou T. n , r\u00e9p\u00e8te l'une des op\u00e9rations f , F , t ou T dans le sens oppos\u00e9. n / motif [/] cr Recherche la premi\u00e8re occurrence de motif n ? motif [?] cr idem mais dans le sens oppos\u00e9. n r\u00e9p\u00e9tition d'une op\u00e9ration /ou ? dans le sens courant N r\u00e9p\u00e9tition d'une op\u00e9ration ?ou / dans le sens oppos\u00e9","title":"Commandes de recherche (cha\u00eene de caract\u00e8res)"},{"location":"unix/#commandes-dinsertion","text":"Le caract\u00e8re Escape permet de repasser en mode commande. commande description a passe en mode entr\u00e9e apr\u00e8s le caract\u00e8re courant. i passe en mode entr\u00e9e avant le caract\u00e8re courant. A passe en mode entr\u00e9e en fin de ligne. I passe en mode entr\u00e9e en d\u00e9but de ligne. o passe en mode entr\u00e9e apr\u00e8s la ligne courante. O passe en mode entr\u00e9e avant la ligne courante. En mode insertion les caract\u00e8res suivant ont un r\u00f4le privil\u00e9gi\u00e9 commande description Escape passage en mode commande. Ctrl-h effacement du caract\u00e8re pr\u00e9c\u00e9dent. (m\u00eame si la visualisation n'est pas Ctrl-v Permet d'introduire dans le fichier tous les caract\u00e8res.","title":"Commandes d'insertion"},{"location":"unix/#commandes-de-modification","text":"commande description n cw chaine Remplace le mot par chaine n cc chaine Remplace les n lignes par chaine n J joint la ligne courante et la suivante. n s chaine Substitue aux n caract\u00e8res la chaine chaine . R Substitution d'une chaine jusqu'\u00e0 Escape r Substitution du caract\u00e8re courant.","title":"Commandes de modification"},{"location":"unix/#commandes-de-recuperation","text":"Chaque op\u00e9ration de suppression ou de modification est stock\u00e9 dans un buffer sp\u00e9cial qu'il est possible de r\u00e9cup\u00e9rer. Il existe plus de 26 buffers num\u00e9rot\u00e9s de a \u00e0 z qu'il est possible d'utiliser. Ils sont not\u00e9s dans le tableau ci-dessous. commande description \" lettre n yw m\u00e9morise n mots dans le buffer lettre \" lettre n yy m\u00e9morise n lignes dans le buffer lettre \" lettre p ins\u00e8re le buffer lettre apr\u00e8s le curseur. \" lettre P ins\u00e8re le buffer lettre avant le curseur. p ins\u00e8re le buffer sp\u00e9cial apr\u00e8s le curseur. P ins\u00e8re le buffer sp\u00e9cial avant le curseur. u annulation de la commande pr\u00e9c\u00e9dente.","title":"Commandes de r\u00e9cup\u00e9ration"},{"location":"unix/#quelques-commandes-particulieres","text":"commande description :se all cr Affiche l'\u00e9tat de l'\u00e9diteur. :se ai cr auto-indentation :se wm= valeur coupure des lignes \u00e0 valeur de la droite de l'\u00e9cran. :se ts= chiffre la valeur des tabulations est positionn\u00e9 \u00e0 chiffre caract\u00e8res (valeur par d\u00e9faut 8) :se nu affichage des num\u00e9rotations de lignes. :syntax on pour aciver la coloration syntaxique (avec vi ) Toutes ces commandes trouvent leur place dans le fichier d'initialisation de vi qui porte le nom \".exrc\" ou \".vimrc\" pour vim .","title":"Quelques commandes particuli\u00e8res"},{"location":"unix/#conclusions","text":"Vi est un \u00e9diteur puissant demandant de la pratique pour \u00eatre pleinement utilis\u00e9. Pour les allergiques \u00e0 vi , il existe aussi un autre \u00e9diteur : emacs . Toutes les possibilit\u00e9s n'ont pas \u00e9t\u00e9 abord\u00e9es ici. Pour plus d'informations se reporter \u00e0 la documentation de votre syst\u00e8me UNIX.","title":"Conclusions"},{"location":"unix/#pipelines-tubes","text":"","title":"Pipelines (tubes)"},{"location":"unix/#introduction_1","text":"Les pipe sont une fonctionnalit\u00e9 tr\u00e8s puissantes dans unix et dans le shell. Ils permettent de cr\u00e9er des commandes sophistiqu\u00e9es \u00e0 partir des commandes de base d'unix. Les sorties d'un processus peuvent \u00eatre redirig\u00e9es vers un fichier. Si un autre processus a besoin de ces donn\u00e9es \u00e0 l'entr\u00e9e on peut les lui donner par l'interm\u00e9daire d'un fichier. Exemple : $ ls fich1 $ wc -l fich1 # Compte le nombre de lignes,donc le nombre de fichier. 12 $ On peut aussi diriger directement les sorties d'un processus en entr\u00e9e d'un autre processus par l'interm\u00e9diaire d'un tube. Le symbole '|' permet de le faire. $ ls toto tata tutu $ # Nombre de fichiers dans le r\u00e9pertoire courant. $ ls | wc -l 3 $ Le symbole '|' indique au shell de prendre le r\u00e9sultat de la commande \"ls\" et de l'envoyer non pas sur l'\u00e9cran, mais sur l'entr\u00e9e de la commande \" wc \". La sortie de la commande \" wc \" n'\u00e9tant pas redirig\u00e9 (dans cet exemple) le r\u00e9sultat s'affiche \u00e0 l'\u00e9cran. La redirection des entr\u00e9es sorties permet d'orienter la commande vers un fichier. Les tubes (pipelines) permettent quand \u00e0 eux de regiriger la sortie d'un processus vers l'entr\u00e9e d'un autre processus.","title":"Introduction"},{"location":"unix/#les-filtres","text":"Les commandes se situant apr\u00e9s le caract\u00e8re '|' doivent \u00eatre des filtres, c'est \u00e0 dire qu'elles doivent prendre leurs donn\u00e9es depuis stdin et afficher le r\u00e9sultat sur stdout. Toutes les commandes ne sont pas des filtres. Les commandes \" cp \", \" mv \", \" who \", \" date \" ne sont pas des filtres, elles ne peuvent donc \u00eatre utilis\u00e9es en bout de tubes. Par contre la commande \" wc \" est un filtre.","title":"Les filtres."},{"location":"unix/#la-commande-sort","text":"Format : sort [-options] [ [ n1 [ n2 ] [ fich1 ..] [ fich2 ] Tri les lignes sur l'entr\u00e9e standard (ou fich1 ) et \u00e9crit le r\u00e9sultat sur la sortie standard (ou fich2 ). le tri est lexicographique sur l'ensemble des fichiers. options description -b les espaces de t\u00eate sont ignor\u00e9s dans les comparaisons. -d Seules les lettres,chiffres et espaces sont significatifs. -f Confond les lettres majuscules et minuscules. -i Ignore les caract\u00e8res ASCII non compris entre 32 et 126 -n le d\u00e9but des lignes num\u00e9riques sont tri\u00e9s num\u00e9riquement. -r Inverse l'ordre. -t x + n O\u00f9 x est un caract\u00e8res quelconque permettant de s\u00e9parer des champs dans des lignes, le tri s'effectue \u00e0 partir du n eme caract\u00e8re x trouv\u00e9. n1 - n2 Limite la comparaisons entre les colonnes n1 et n2-1 La commande \"sort\" poss\u00e8de de nombreuses autres options, se reporter \u00e0 la documentation de votre syst\u00e8me UNIX. Exemple : R\u00e9pertoire de num\u00e9ro de postes. $cat numpost gilbert:611:bureau de d\u00e9veloppement daniel:344:bureau d \u00e9tudes val\u00e9rie:312:sec\u00e9taire $ $ sort numpost # tri alphab\u00e9tique sur les lignes daniel:344:bureau d \u00e9tudes gilbert:611:bureau de d\u00e9veloppement val\u00e9rie:312:sec\u00e9taire $ $ sort -n -t: +1 numpost ; # tri num\u00e9rique sur le 2\u00e9me champ val\u00e9rie:312:sec\u00e9taire daniel:344:bureau d \u00e9tudes gilbert:611:bureau de d\u00e9veloppement $","title":"La commande sort"},{"location":"unix/#la-commande-grep","text":"Format : grep [-options] ' motif ' [fich ...] La commande \" grep \" recherche dans les fichiers sp\u00e9cifi\u00e9s (ou stdin) le motif sp\u00e9cifi\u00e9et affiche ces lignes. Si la recherche s'effectue sur plusieurs fichiers \"grep\" affiche en d\u00e9but de ligne le nom du fichier. options description -n Imprime le num\u00e9ro de ligne et la ligne. -n Affiche les lignes ne contenant pas le motif sp\u00e9cifi\u00e9. -l Seuls les num\u00e9ros de lignes sont sp\u00e9cifi\u00e9s. -c Affiche uniquement le nombre de ligne contenant le motif le motif est \u00e9crit entre quotes \" ' \" . Exemple : $ grep -v bureau numpost val\u00e9rie:312:sec\u00e9taire $","title":"La commande \"grep\""},{"location":"unix/#tubes-et-redirections-dio","text":"Les redirections permet d'orienter la sortie d'un processus (c'est \u00e0 dire le resultat d'un programme), tandis que les tubes (pipelines) permettent de rediriger les sorties d'un processus vers l'entr\u00e9e d'un autre processus; c'est donc une communication entre processus. Exemples de tubes : $ ls | wc -l # donne le nombre de fichier dans le r\u00e9pertoire courant 32 $ ls .. | wc -l # donne le nombre de fichier dans le r\u00e9pertoire p\u00e8re 3 $ who | wc -l # donne le nombre de personnes connect\u00e9es 4 $ # Exemple de tube avec redirection. $ echo Nombre de gens connect\u00e9s \u00e0 la date de fich $ date fich $ echo -n est : fich $ who | wc -l fich $ cat fich Nombre de gens connect\u00e9s \u00e0 la date de Tue Jan 12 18 :43 GMT 1988 est 4 $","title":"tubes et redirections d'I/O"},{"location":"unix/#quelques-filtres-usuels","text":"","title":"Quelques filtres usuels"},{"location":"unix/#la-commande-pr","text":"Format : pr [-options] [fichier ...] La commande pr permet de formatter du texte sur la sortie standard. Sans option affiche avec un en-t\u00eate et une num\u00e9rotation de page. C'est une commande tr\u00e9s puissante. Quelques options : options description + n D\u00e9bute \u00e0 la page de num\u00e9ro donn\u00e9. - n Impression sur le nombre de colonnes donn\u00e9 (1 par d\u00e9faut). -m Imprime les fichiers \u00e0 raison de 1 par colonne. -d Ins\u00e8re une ligne blanche entre chaque ligne. -w n Largeur d'une ligne (72 par d\u00e9faut). -l n Chaque page contient n lignes. -h L'argument suivant est utilis\u00e9 comme en-t\u00eate \u00e0 chaque page -p Interruption entre chaque page ( cr pour continuer) -t Les 5 premi\u00e8res lignes de l'ent\u00eate ne sont pas imprim\u00e9es","title":"La commande \"pr\""},{"location":"unix/#la-commande-paste","text":"Format : paste [options] [fichier ...] Les lignes de chaque fichier sont consid\u00e9r\u00e9es comme des colonnes s\u00e9par\u00e9es par d\u00e9faut par des tabulations. Exemple : $ cat fich1 aa ab ac $ cat fich2 ba bb bc $ paste fich1 fich2 aa ba ab bb ac bc $","title":"La commande \"paste\""},{"location":"unix/#la-commande-pg","text":"Format : pg [ n ] [-p chaine ] [-options] [ n ] [files...] Permet l'affichage de texte avec arr\u00eat entre chaque page et possibilit\u00e9 de retour arri\u00e8re. n Sp\u00e9cifie le nombre de ligne \u00e0 afficher.(par d\u00e9faut 23) -p chaine chaine est utilis\u00e9 comme prompt (par d\u00e9faut \":\") Quelques options: -c Efface l'\u00e9cran avant l'affichage de chaque page. -e Enl\u00e8ve l'arr\u00e8t entre chaque fichiers. + n1 Commence \u00e0 la ligne n1 Quelques commandes de \"pg\": cr affichage d'une nouvelle page. h Affiche une aide sur les commandes disponibles. ! commande Execute une commande du shell.","title":"La commande \"pg\""},{"location":"unix/#la-commande-lp","text":"Format : lp [fichier...] Permet d'imprimer sur l'imprimante locale les fichiers sp\u00e9cifi\u00e9s (ou ce qui est \u00e9crit depuis l'entr\u00e9e standard, caract\u00e8re fin de fichier pour terminer).","title":"La commande \"lp\""},{"location":"unix/#le-shellprogrammation-et-environnement","text":"","title":"Le Shell,Programmation et Environnement"},{"location":"unix/#lenvironnement","text":"Nous avons vu que lorsqu'un processus lance un autre processus, celui ci h\u00e9rite de l'environnement du processus qui l'a lanc\u00e9. L'\u00e9diteur vi utilise la variable TERM de l'environnement. L'environnement est constitu\u00e9 en grande partie de variables comme la variable TERM. Les programmes ont aussi des variables qui leur sont propres. On distingue deux types d'environnement : L'environnement global commun \u00e0 tous les processus. L'environnement local \u00e0 un processus. c'est l'environnement associ\u00e9 au processus. Certaines variables sont d\u00e9j\u00e0 d\u00e9finis et ont une utilisation sp\u00e9cifique.","title":"L'environnement."},{"location":"unix/#la-commande-set","text":"Permet d'avoir l'environnement local du shell en cours. $ set PATH = :/bin:/usr/bin TERM = vt100 HOME = /home/daniel PS1 = \\$ PS2 = $ PATH Sp\u00e9cifie les r\u00e9pertoires o\u00f9 seront cherch\u00e9s les commandes. Le caract\u00e8re \":\" \u00e9tant le s\u00e9parateur sauf le premier qui sp\u00e9cifie le r\u00e9pertoire courant. dans le cas pr\u00e9sent le shell ira chercher les programmes dans : le r\u00e9pertoire courant le r\u00e9pertoire /bin le r\u00e9pertoire /usr/bin TERM Sp\u00e9cifie le terminal qui est utilis\u00e9. HOME Le r\u00e9pertoire du login,c'est le r\u00e9pertoire qui est pris par la commande \"cd\". PS1 Le prompt du shell. PS2 Le deuxi\u00e8me prompt du shell","title":"La commande \"set\""},{"location":"unix/#la-commande-export","text":"Format : export variable [variables ...] Permet de rendre une variable globale. Les variables globales sont pass\u00e9es aux processus fils. $ VARIABLE_LOCALE = local $ VARIABLE_GLOBALE = global $ set | grep VARIABLE $ VARIABLE_LOCALE = local $ VARIABLE_GLOBALE = global $ export VARIABLE_GLOBALE $ sh $ set | grep VARIABLE $ VARIABLE_GLOBALE = global $","title":"La commande \"export\""},{"location":"unix/#la-commande-env","text":"Permet d'avoir la liste des variables globales. Ces variables seront pass\u00e9es aux processus fils. Lorsqu'un processus fils est lanc\u00e9 il obtient une copie de l'environnement du p\u00e8re, toutes ces t\u00e2ches se feront dans cette copie. C'est pourquoi un processus fils ne peut pas modifier l'environnement du p\u00e8re. Il est impossible de faire un \"export\" ascendant du fils vers le p\u00e8re.","title":"La commande \"env\""},{"location":"unix/#affectation-des-variables","text":"nom_de_variable = valeur Les noms de variable commencent par une lettre et sont compos\u00e9s de lettres, chiffres et du caract\u00e8res \"_\" On peut affecter \u00e0 une variable la valeur d'une autre variable, pour cela il faut faire pr\u00e9c\u00e9der cette derni\u00e8re par le caract\u00e8re \"\\$\". Si les variables se trouvent au milieu d'une ligne il faut entourer le nom de la variable par deux accolades \"{ }\". Exemple: $ VARL = locale $ echo $VARL locale $ echo La temp\u00e9rature $VARL est de 10 degr\u00e9s La temp\u00e9rature locale est de 10 degr\u00e9s $ echo Les temp\u00e9ratures ${ VARL } s sont chaudes Les temp\u00e9ratures locales sont chaudes $","title":"Affectation des variables"},{"location":"unix/#les-caracteres-speciaux","text":"Nous avons vu d\u00e9j\u00e0 certains caract\u00e8res sp\u00e9ciaux, \\$ signifie que la suite est une variable d'environnement, les accolades {} permettent de d\u00e9limiter le nom d'une variable, l'espace est consid\u00e9r\u00e9 comme \u00e9tant le s\u00e9parateur. Il est parfois n\u00e9cessaire de pouvoir outrepasser un caract\u00e8re, Il existe trois moyens : \\ le caract\u00e8re backslash ou barre oblique inverse '' deux simples quotes \"\" deux guillemets Le backslash annihile le r\u00f4le d'un caract\u00e8re sp\u00e9cial. Exemple : \\\\$var ne sera pas interpr\u00e9t\u00e9 comme le contenu de la variable var mais comme la chaine \\$var . \\\\ donnera le caract\u00e8re \\ Les simples quotes sont utilis\u00e9s pour marquer plusieurs caract\u00e8res. Les guillemets annulent toutes interpr\u00e9tation des caract\u00e8res \u00e0 l'exception des caract\u00e8res : \\'\"\\$ dont l'interpr\u00e9tation peut \u00eatre annul\u00e9e s'ils sont pr\u00e9c\u00e9d\u00e9s de \\","title":"Les caract\u00e8res sp\u00e9ciaux"},{"location":"unix/#les-noms-implicites-de-fichiers","text":"Il existe un syst\u00e8me de g\u00e9n\u00e9ration de fichiers. Une partie du nom d'un fichier peut \u00eatre remplac\u00e9e par des caract\u00e8res jokers: caract\u00e8re(s) description * Remplace un nombre quelconque de caract\u00e8res. ? Remplace un seul caract\u00e8re. `[] D\u00e9fini une classe de caract\u00e8res. .. Une suite de caract\u00e8res. ! n\u00e9gation d'une classe de caract\u00e8res. Exemple: $ ls * ; # idem \u00e0 ls tout seul toto tata $ ls to* to $ ls t [ a-i ] t* tata $ ls t [ ao ] * toto tata $ Note : Les m\u00e9ta-caract\u00e8res ne d\u00e9tectent pas les fichiers commen\u00e7ant par le caract\u00e8re \".\".","title":"Les noms implicites de fichiers"},{"location":"unix/#le-fichier-profile","text":"Lorsque que l'on se connecte, on se retrouve avec un certain environnement. Cet environnement peut \u00eatre modifi\u00e9 en modifiant le fichier .profile qui se trouve dans le r\u00e9pertoire par d\u00e9faut de l'utilisateur (rep\u00e9r\u00e9 par la variable d'environnment $HOME ). Les fichiers commen\u00e7ant par le caract\u00e8re \".\" n'apparassent pas avec la commande \"ls\" (il faut utiliser l'option -a ). Lors de la connexion le fichier .profile sera ex\u00e9cut\u00e9 par le shell. Exemple : $ cd $ echo echo Bonjour Daniel .profile $ exit login: daniel password: xxxxxxx Bonjour Daniel $","title":"Le fichier .profile"},{"location":"unix/#introduction-a-la-programmation-en-shell","text":"Le shell est un langage de commande interpr\u00e9t\u00e9. Un programme shell est donc un fichier texte contenant un ensemble de commandes, Il est rendu ex\u00e9cutable par la commande \"chmod\". Le shell est un langage puissant mais est tr\u00e8s peu pratique pour les calculs arithm\u00e9tiques. Exemple de programme shell: $ cat dir ls -a $ dir . .. .profile dir $ De m\u00eame que pour les commandes on peut passer des param\u00e8tres aux programmes shell. les variables pass\u00e9es en param\u00e8tres sont de la forme \\$ n ou n est un chiffre. \\$0 est le nom du programme \\$1 \u00e0 \\$9 sont les arguments pass\u00e9s en param\u00e8tres. Exemple : $ cat mon_echo echo $0 $1 $mon_echo mon_echo Bonjour Bonjour $ $ cat rend_executable chmod +x $1 echo $1 est devenu un programme executable. $rend_executable dir dir est devenu un programme executable. $ On peut programmer directement en shell depuis la ligne de commande. Exemple: $ for i in 1 2 3 ; do echo bonjour ; done bonjour bonjour bonjour $ for i in 1 2 do echo bonjour done bonjour bonjour $ Ici nous avons ex\u00e9cut\u00e9 une boucle de deux mani\u00e8res diff\u00e9rentes. La premi\u00e8re fois nous avons \u00e9crit l'instruction compl\u00e8te, le shell l'a ex\u00e9cut\u00e9. La deuxi\u00e8me fois nous avons \u00e9crit l'instruction partiellement, le shell s'en rendant compte nous affiche le deuxi\u00e8me prompt (PS2) pour nous indiquer qu'il attendla suite de l'instruction pour l'ex\u00e9cuter. Se reporter \u00e0 la documentation UNIX pour avoir une description compl\u00e8te de possibilit\u00e9s du langage shell.","title":"Introduction \u00e0 la programmation en shell"},{"location":"unix/#communications-entre-utilisateurs","text":"","title":"Communications entre utilisateurs"},{"location":"unix/#introduction_2","text":"UNIX offre les possibilit\u00e9s suivantes: Messagerie \u00e9lectronique : envoi,r\u00e9ception de messages Gestion d'un journal de bord. Conversation en temps r\u00e9el.","title":"Introduction"},{"location":"unix/#messagerie","text":"Au moment du login UNIX vous avertie, si vous avez du courrier par le message suivant : \"You have mail\"","title":"Messagerie."},{"location":"unix/#la-commande-mail","text":"Format : mail [-r] [-f fichier ] ou : mail nom [ nom ...]","title":"La commande \"mail\""},{"location":"unix/#la-commande-mailx","text":"La commande \"mailx\" est une mani\u00e8re plus agr\u00e9able d'examiner son courrier. Elle donne une liste num\u00e9rot\u00e9e des messages que vous n'avez pas encore lus. Vous pouvez lire un message en entrant son num\u00e9ro, chaque message \u00e0 un sujet. Chaque message lu passe de la boite au lettres syst\u00e8me \u00e0 un fichier appel\u00e9 \"mbox\" dans votre home directory (Le r\u00e9pertoire de login) Quelques options: -f fichier Lit les messages depuis fichier sinon depuis \"mbox\". -N n'affiche pas le sommaire. -n nom Lit les messages de nom si l'on a les droits d'acc\u00e8s. La commande \"mailx\" est plus sophistiqu\u00e9e que la commande \"mail\", se reporter \u00e0 la documentation UNIX pour plus de d\u00e9tails.","title":"La commande \"mailx\""},{"location":"unix/#le-journal-de-bord","text":"UNIX permet de g\u00e9rer un v\u00e9ritable journal de bord. Les nouvelles sont stock\u00e9es dans le r\u00e9pertoire /usr/news.","title":"Le journal de bord."},{"location":"unix/#la-commande-news","text":"Format : news [options] [ fichiers ...] Permet de lire le journal de bord. options -a toutes les nouvelles sont supprim\u00e9es qu'elles aient ou non d\u00e9j\u00e0 \u00e9t\u00e9 consult\u00e9es par l'utilisateur. -n Les noms des nouvelles sont seules imprim\u00e9es. -s indique uniquement le nombre de nouvelles disponibles.","title":"La commande \"news\""},{"location":"unix/#la-conversation-en-temps-reel","text":"UNIX permet \u00e0 deux utilisateurs connect\u00e9s au syst\u00e8me de converser en direct.","title":"La conversation en temps r\u00e9el"},{"location":"unix/#la-commande-mesg","text":"Permet d'accepter ou de refuser les conversations en direct. Ceci est utile lorsque l'on travaille sous un \u00e9diteur par exemple pour \u00e9viter d'avoir des messages parasites. options: -y Accepte les messages. -n Refuse les messages.","title":"La commande \"mesg\""},{"location":"unix/#la-commande-write","text":"Format : write nom [ terminal ] Permet de communiquer directement avec un autre utilisateur si celui ci est connect\u00e9 et s'il accepte les messages (commande \"mesg\") Sur l' \u00e9cran du destinataire appara\u00eet le message suivant : \"message from ...\" La conversation se fait en direct jusqu'\u00e0que l'un des interlocuteurs appuie sur fin de fichier ( Ctrl-d ).","title":"La commande \"write\""},{"location":"unix/#sauvegarde-et-archivage-des-fichiers","text":"","title":"Sauvegarde et archivage des fichiers."},{"location":"unix/#la-commande-find","text":"Format : find liste de chemins expressions Permet une recherche automatique de fichiers dans une partie de l'arborescence (recherche r\u00e9cursive) du syst\u00e8me de fichiers de UNIX. C'est une commande tr\u00e8s gourmande en temps CPU, \u00e0 utiliser avec mod\u00e9ration. liste de chemins est la liste des r\u00e9pertoires de recherches expressions D\u00e9fini le type de recherche. convention d' \u00e9critures: n sans signe signifie :\u00e9gale valeur n avec le signe plus signifie: sup\u00e9rieur ou \u00e9gal\u00e0n. n avec le signe moins signifie : inf\u00e9rieur ou \u00e9gal\u00e0n. options: -name nom Vrai si le fichier a pourr\u00e9f\u00e9rence nom -perm nombre en octal Vrai si le fichier a pour droit d'acc\u00e8s ... -type x Vrai si le type de fichier est x . x : b fichier sp\u00e9cial de type block c fichier sp\u00e9cial de type caract\u00e8re d fichier de type catalogue f fichier de type ordinaire. p pour les tubes nomm\u00e9s.(System III etV) -links n Vrai si le fichiera n liens. -user nom Vrai si le fichierapour propri\u00e9taire nom -group nom Idem pour le groupe d'utilisateur. -size n Vrai si le fichier a n blocs. -atime n Vrai si le fichier a \u00e9t\u00e9 consult\u00e9 depuis n jours -mtime n Vrai si le fichier a \u00e9t\u00e9 modifi\u00e9depuis n jours. -inum n Vrai si le fichier a pour i-node n . -print Affiche les noms des fichiers r\u00e9pondant \u00e0 expressions . Toutes ces primitives peuvent \u00eatre compos\u00e9es avec l'op\u00e9rateur de n\u00e9gation \"!\".","title":"La commande \"find\""},{"location":"unix/#la-commande-cpio","text":"C'est la commande de sauvegarde des fichiers et des r\u00e9pertoires. Elle s'emploie selon trois formes, par d\u00e9faut la commande attend la liste des fichiers \u00e0 sauvegarder depuis l'entr\u00e9e standard ( Ctrl-d pour terminer). Elle s'utilise le plus souvent avec la commande \"find\".","title":"La commande \"cpio\""},{"location":"unix/#cpio-p-directory","text":"Format : cpio -p [adlmruv] r\u00e9pertoire Lit la liste des fichiers \u00e0 sauvegarder sur l'entr\u00e9e standard et les sauvegarde dans r\u00e9pertoire .","title":"cpio -p &lt;directory&gt;"},{"location":"unix/#cpio-o-output-sortie","text":"Format : cpio -o [aBcv] copie les fichiers sur la sortie standard en indiquant le chemin et le statuts.","title":"cpio -o (output = sortie)"},{"location":"unix/#cpio-i-input-entree","text":"Format : cpio -i [BcdmrtuvfsSb] [patterns] Lit l'entr\u00e9e standard et recr\u00e9e la structure de l'arborescence indiqu\u00e9e par l'entr\u00e9e.","title":"cpio -i (input = entr\u00e9e)"},{"location":"unix/#les-options","text":"a Remet \u00e0 0 les temps d'acc\u00e8s des fichiers d'entr\u00e9es. B l'entr\u00e9e et la sortie se font par bloc de 5120 octets (A n'utiliser qu'avec redirection sur des devices par blocs, des lecteurs de bandes par exemple). d Les r\u00e9pertoires sont cr\u00e9\u00e9s s'il y a lieu. c Ecrit l'en-t\u00eate en ASCII (pour la portabilit\u00e9). r Renomme les fichiers (de mani\u00e8re interactive) t Affiche la liste des fichiers d'entr\u00e9es (Rien n'est cr\u00e9\u00e9, utile pour v\u00e9rifier que tout c'est bien pass\u00e9). u copie inconditionnelle (normalement les fichiers plus anciens ne remplacent pas les fichiers plus jeunes). v affiche sur la sortie une liste des fichiers affich\u00e9s. l Essaye de cr\u00e9er des liens plut\u00f4t que la recopie des fichiers. f copie tout les fichiers sauf ceux d\u00e9finis dans [patterns] s \u00e9change l'ordre des octets. S \u00e9change l'ordre des demi-mots. b \u00e9quivalent aux options s et S.","title":"Les options:"},{"location":"unix/#la-commande-tar","text":"Format : tar [ cl\u00e9s ] [ fichiers ...] Permet d'archiver des fichiers sur un fichier unique sur bande magn\u00e9tique, ainsi que leur restitutions cl\u00e9s Permet de contr\u00f4ler le type d'op\u00e9ration : r Ecriture des fichiers en fin de bande. x Extraction des fichiers de la bande, si le nom est un r\u00e9pertoire il est cr\u00e9\u00e9 et les caract\u00e9ristiques des fichiers sont respect\u00e9s si possibles. t Liste les fichiers de la bande sans extraction. u Sauvegarde les fichiers en fin de bande s'ils n'y sont pas d\u00e9j\u00e0. c Cr\u00e9ation d'une nouvelle bande.(sauvegarde en d\u00e9but de bande) Les param\u00e8tres des cl\u00e9s sont les suivants: 0..7 S\u00e9lectionne le d\u00e9rouleur de bande. v Le nom de chaque fichier est affich\u00e9 w Avant chaque op\u00e9ration affiche le fichier en cours et demande confirmation \u00e0 l'utilisateur. f Le nom de l'argument suivant est utilis\u00e9 comme r\u00e9f\u00e9rence du fichier d'archive.(Par d\u00e9faut c'est /dev/rmt0 (d\u00e9rouleur de bande 0) m Demande la non-restitution de la date,la date courante est alors utilis\u00e9e. z Compresse ou d\u00e9compresse les donn\u00e9es suivant les cas Note Il n'y a pas de caract\u00e8re \"-\" au d\u00e9but des options !!. Si le nom du fichier avec l'option f est \"-\" c'est la sortie standard qui est utilis\u00e9e. Exemple: r\u00e9copie du r\u00e9pertoire courant vers un autre endroit $ tar cf - . | ( cd /tmp ; tar xvf - )","title":"La commande \"tar\""},{"location":"unix/#la-commande-ar","text":"Format : ar [options] nom de librairie [ liste-de-fichiers ] Permet d'archiver des fichiers et de cr\u00e9er des biblioth\u00e8ques de fichiers objets (pour les compilateurs.) options: -d supprime les fichiers sp\u00e9cifi\u00e9s de la biblioth\u00e8que. -r Remplace les fichiers sp\u00e9cifi\u00e9 dans la biblioth\u00e8que. -q Rajout des fichiers en fin de biblioth\u00e8que. -t Impression du contenu des fichiers de la biblioth\u00e8que ou de la liste des fichiers -p Impression des modules de la biblioth\u00e8que. -m d\u00e9placement des modules en fin de biblioth\u00e8que. -x Extraction des fichiers de la biblioth\u00e8que. -v option d'affichage d\u00e9taill\u00e9.","title":"La commande \"ar\""},{"location":"unix/#la-commande-cmp","text":"Format : cmp [option] fichier1 fichier2 Permet de comparer deux fichiers. options : -l Toutes les diff\u00e9rences sont signal\u00e9es par le num\u00e9ro du caract\u00e8re en d\u00e9cimal et sa valeur en octal. -s aucune sortie, la commande est utilis\u00e9e pour avoir un code de sortie.","title":"La commande \"cmp\""},{"location":"unix/#commandes-additionnelles","text":"","title":"Commandes additionnelles"},{"location":"unix/#la-commande-crypt","text":"Permet de coder un fichier, affiche sur la sortie standard le fichier cod\u00e9. Les fichiers sont cod\u00e9 par un algorithme en fonction de la cl\u00e9 que vous donnez.","title":"La commande \"crypt\""},{"location":"unix/#la-commande-od","text":"Format : od [options] fichier Permet de r\u00e9aliser un \"dump\" du fichier sp\u00e9cifi\u00e9.(par d\u00e9faut en octal.) . options: -b Les mots sont interpr\u00e9t\u00e9s en octal -c les octets sont interpr\u00e9t\u00e9s en ASCII -d Les mots sont interpr\u00e9t\u00e9s en d\u00e9cimal -o Les mots sont interpr\u00e9t\u00e9s en octal -x les mots sont interpr\u00e9t\u00e9s en hexad\u00e9cimal","title":"La commande \"od\""},{"location":"unix/#la-commande-touch","text":"Format : touch [options] [date] fichier ... Permet de changer la date de derni\u00e8re modification des fichiers sp\u00e9cifi\u00e9s. Si aucune date n'est donn\u00e9e, la date courante est utilis\u00e9e. options: -a Change la date d'acc\u00e8s. -m Change la date de modification. -c Emp\u00eache la fonction \"touch\" de cr\u00e9er le fichier si celui-ci n'existe pas.","title":"La commande \"touch\""},{"location":"unix/#la-commande-split","text":"Format : split [- n ] [ fichier [ nom ] ] Permet de d\u00e9couper un fichier en plusieurs fichiers. Par d\u00e9faut d\u00e9coupe le fichier toute les 1000 lignes si - n n'est pas sp\u00e9cifi\u00e9 . Les fichiers de sorties ont pour nom nom avec les lettres 'aa' \u00e0 'zz' (au maximum 676 fichiers) Si nom n'est pas sp\u00e9cifi\u00e9 \"x\" est pris par d\u00e9faut.","title":"La commande \"split\""},{"location":"unix/#les-commandes-dadministration-du-systeme","text":"","title":"Les commandes d'administration du syst\u00e8me."},{"location":"unix/#la-commande-su","text":"Permet de passer en mode super-utilisateur(Plus de protection dans le syst\u00e8me UNIX, \u00e0 condition d'avoir le mot de passe. Plut\u00f4t remplac\u00e9 par sudo qui permet de donner des acc\u00e8s \u00e0 certaines commandes \u00e0 un utilisateur donn\u00e9 sans que celui-ci ne connaisse le mot de passe de root. DE nos jours on \u00e9vtite de passer en root directement, on passe plut\u00f4t par la commande sudo qui permet de donner des droits plus fin aux utilisateurs.","title":"La commande \"su\""},{"location":"unix/#la-commande-sar","text":"Permet d'avoir des renseignements sur l'activit\u00e9 du syst\u00e8me UNIX. Se reporter \u00e0 la documentation UNIX pour plus de d\u00e9tails.","title":"La commande \"sar\":"},{"location":"unix/#la-commande-sysadm","text":"\"sysadm\" est une interface pour g\u00e9rer le syst\u00e8me. (administration du syst\u00e8me.). n\u00e9cessite de conna\u00eetre le mot de passe. Se reporter \u00e0 la documentation pour plus de d\u00e9tails.","title":"La commande \"sysadm\""},{"location":"unix/#la-commande-de-configuration-du-terminal-stty","text":"Format : stty [-a][-g] [options] La commande \"stty\" permet de conna\u00eetre l'\u00e9tat du param\u00e9trage de la ligne du terminal ainsi que de le reconfigurer. Sans arguments donne l'\u00e9tat de la ligne. -a donne l'\u00e9tat complet de la ligne. -g donne l'\u00e9tat de la ligne dans un format permettant de configurer un autre terminal (via les tubes). Sans \"-\" pour actionn\u00e9 l'option, Avec \"-\" pour la d\u00e9sactiver.","title":"La commande de configuration du terminal \"stty\""},{"location":"unix/#les-modes-de-controles","text":"parenb autorise le contr\u00f4le de parit\u00e9. parodd parit\u00e9 impaire cs5 cs6 cs6 cs8 Nombre de bits de donn\u00e9es. 50..300...1200..9800 Vitesse de transmission de la ligne. cstopbutilise 1 bits de stop (sinon 2)","title":"Les modes de contr\u00f4les"},{"location":"unix/#les-modes-dentree","text":"ignbrk ignore le break; ignpar ignore les erreurs de parit\u00e9. istrip compacte sur 7 bits les donn\u00e9es. inclr le caract\u00e8re New-line est interpr\u00e9t\u00e9 comme return icrnl le return est interpr\u00e9t\u00e9 comme new-line iuclc Interpr\u00e8te les majuscules comme des minuscules. ixon Autorise le contr\u00f4le de flux ( Ctrl-s ) ixany Tout caract\u00e8re relance l'affichage (sinon uniquement Ctrl-q ) ixoff Le syst\u00e8me envoie des START/STOP suivant l'\u00e9tat des buffers","title":"Les modes d'entr\u00e9e"},{"location":"unix/#les-modes-de-sortie","text":"opost Les caract\u00e8res en sortie doivent \u00eatre traiter (par l'une des options suivantes) olcuc identifie les minuscules en majuscules onlcr new-line comme la suite return new-line onocr les return en t\u00eate de ligne sont ignor\u00e9s. onlret sur le terminal new-line est interpr\u00e9t\u00e9 comme return","title":"Les modes de sortie"},{"location":"unix/#les-modes-locaux","text":"echo envoie l'\u00e9cho de chaque caract\u00e8re echoe l'\u00e9cho du caract\u00e8re erase est la suite backspace espace backspace icanonles caract\u00e8res sont entr\u00e9s en modes lignes d\u00e9limit\u00e9s par new-line noflshne vide pas les buffers apr\u00e8s une interruption INTR, QUIT, ou SWTCH isig Autorise le test des caract\u00e8res en entr\u00e9e pour d\u00e9tecter les interruptions INTR,QUIT,SWTCH Se reporter \u00e0 la documentation pour une information plus d\u00e9taill\u00e9e.","title":"Les modes locaux"}]}